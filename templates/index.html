<!DOCTYPE html>
<html>
<head>
    <title>Laser Turret Control Panel</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/index.css') }}">
<!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Laser Turret Control Panel</h1>
            <p>Advanced Camera Control & Monitoring System</p>
        </div>

        <div class="control-layout">
            <section class="video-section">
                <div class="video-wrapper">
                    <img id="video-stream" src="{{ url_for('video_feed') }}" alt="Video stream">

                    <div class="overlay-toolbar">
                        <button id="motors-toggle" class="toolbar-button" onclick="toggleMotorsFromToolbar(this)">
                            Motors
                            <span class="state-pill" id="motors-state">--</span>
                        </button>
                        <button class="toolbar-button active" data-overlay-target="movement" onclick="toggleOverlayPanel('movement-overlay', this)">Movement</button>
                        <button class="toolbar-button" data-overlay-target="objects" onclick="toggleOverlayPanel('objects-overlay', this)">Objects</button>
                        <button class="toolbar-button" data-overlay-target="laser" onclick="toggleOverlayPanel('laser-overlay', this)">Laser</button>
                    </div>

                    <div class="overlay-panel floating-controls movement-overlay active" id="movement-overlay" data-overlay-key="movement">
                        <div class="direction-pad">
                            <span class="spacer"></span>
                            <button class="pad-button" onclick="manualMove('y', -1)" aria-label="Nudge up" title="Nudge up">‚ñ≤</button>
                            <span class="spacer"></span>
                            <button class="pad-button" onclick="manualMove('x', -1)" aria-label="Nudge left" title="Nudge left">‚óÑ</button>
                            <button class="pad-button fire-button" data-fire-control onclick="fireLaser(this)" aria-label="Fire laser" title="Fire laser">
                                <span>Fire</span>
                            </button>
                            <button class="pad-button" onclick="manualMove('x', 1)" aria-label="Nudge right" title="Nudge right">‚ñ∫</button>
                            <span class="spacer"></span>
                            <button class="pad-button" onclick="manualMove('y', 1)" aria-label="Nudge down" title="Nudge down">‚ñº</button>
                            <span class="spacer"></span>
                        </div>
                        <div class="floating-slider overlay-slider">
                            <label for="manual-step-size" style="display: flex; justify-content: space-between; align-items: center;">
                                <span>Step Size</span>
                                <span id="manual-step-size-value" class="floating-slider-value overlay-slider-value">100 px</span>
                            </label>
                            <input type="range" id="manual-step-size" min="10" max="500" value="100" step="10" oninput="updateManualStepSize()">
                        </div>
                        <div class="icon-action-row">
                            <button class="icon-action" onclick="setHomePosition()" aria-label="Set current position as home" title="Set current position as home">üìç</button>
                            <button class="icon-action" onclick="homeCameraPosition()" aria-label="Move to saved home position" title="Return to Home">üè†</button>
                            <button class="icon-action" onclick="runAutoCalibration()" aria-label="Run auto calibration" title="Auto Calibration">ü§ñ</button>
                            <button class="icon-action" id="recenter-toggle-btn" onclick="toggleOverlayRecenter(this)" aria-label="Toggle re-center on target loss" title="Re-center on Target Loss">üéØ</button>
                        </div>
                    </div>

                    <div class="overlay-panel laser-overlay" id="laser-overlay" data-overlay-key="laser">
                        <button class="pad-button fire-button" data-fire-control onclick="fireLaser(this)" aria-label="Fire laser" title="Fire laser" style="width: 100%; height: 60px;">
                            <span>Fire</span>
                            <span>Laser</span>
                        </button>
                        <div class="overlay-toggle-grid">
                            <button id="overlay-laser-enable" class="overlay-toggle-chip" onclick="toggleLaserFromOverlay()">Laser System</button>
                            <button id="overlay-auto-fire" class="overlay-toggle-chip" onclick="toggleAutoFireFromOverlay()">Auto Fire</button>
                            <button id="overlay-mock-fire" class="overlay-toggle-chip" onclick="toggleMockFireFromOverlay()">Mock Fire</button>
                        </div>
                        <div class="overlay-status-grid">
                            <div>
                                <span class="overlay-status-label">System</span>
                                <span id="overlay-laser-status" class="overlay-status-value">OFF</span>
                            </div>
                            <div>
                                <span class="overlay-status-label">Ready</span>
                                <span id="overlay-laser-ready" class="overlay-status-value">No</span>
                            </div>
                            <div>
                                <span class="overlay-status-label">Power</span>
                                <span id="overlay-laser-power" class="overlay-status-value">100%</span>
                            </div>
                            <div>
                                <span class="overlay-status-label">Cooldown</span>
                                <span id="overlay-laser-cooldown" class="overlay-status-value">Ready</span>
                            </div>
                        </div>
                    </div>

                    <div class="overlay-panel objects-overlay" id="objects-overlay" data-overlay-key="objects">
                        <div class="overlay-toggle-grid">
                            <button id="overlay-objects-detect" class="overlay-toggle-chip" onclick="toggleObjectDetectionFromOverlay()">Detection</button>
                            <button id="overlay-objects-track" class="overlay-toggle-chip" onclick="toggleObjectAutoTrackFromOverlay()">Auto-Track</button>
                        </div>
                        <div class="overlay-slider">
                            <label for="overlay-object-confidence" style="display: flex; justify-content: space-between; align-items: center;">
                                <span>Confidence Threshold</span>
                                <span id="overlay-object-confidence-value" class="overlay-slider-value">0.50</span>
                            </label>
                            <input type="range" id="overlay-object-confidence" min="0.1" max="0.9" step="0.05" value="0.5" oninput="handleOverlayConfidenceInput(this.value)">
                        </div>
                        <div id="overlay-object-hint" class="overlay-empty" style="display: none;">
                            Confidence control unavailable for the current detection method.
                        </div>
                    </div>
                </div>
            </section>

            <aside class="controls-panel">
                <div class="controls-header">
                    <h2>Control Center</h2>
                    <p>Switch between system status, targeting, automation, and imaging tools.</p>
                </div>

                <div class="panel-body">
                    <nav class="tab-navigation">
                        <div class="nav-section">
                            <span class="nav-label">Overview</span>
                            <button class="tab active" data-tab="stats" onclick="switchTab('stats', this)">üìä Status</button>
                        </div>
                        <div class="nav-section">
                            <span class="nav-label">Targeting</span>
                            <button class="tab" data-tab="tracking" onclick="switchTab('tracking', this)">üéØ Tracking</button>
                            <button class="tab" data-tab="laser" onclick="switchTab('laser', this)">üî¥ Laser</button>
                        </div>
                        <div class="nav-section">
                            <span class="nav-label">Automation</span>
                            <button class="tab" data-tab="presets" onclick="switchTab('presets', this)">üìç Presets</button>
                            <button class="tab" data-tab="object" onclick="switchTab('object', this)">üë§ Objects</button>
                            <button class="tab" data-tab="motion" onclick="switchTab('motion', this)">üéØ Motion</button>
                        </div>
                        <div class="nav-section">
                            <span class="nav-label">Imaging</span>
                            <button class="tab" data-tab="exposure" onclick="switchTab('exposure', this)">üîÜ Exposure</button>
                            <button class="tab" data-tab="image" onclick="switchTab('image', this)">üé® Image</button>
                            <button class="tab" data-tab="capture" onclick="switchTab('capture', this)">üì∏ Capture</button>
                        </div>
                    </nav>

                    <div class="tab-content-area">
                        <!-- Stats Tab -->
                        <div id="stats-tab" class="tab-content active">
                    <div class="control-group">
                        <h3>üìç Crosshair Position</h3>
                        <div class="stat-row">
                            <span class="stat-label">Position</span>
                            <span id="position" class="stat-value">Center</span>
                        </div>
                        <button class="btn-secondary" onclick="resetCrosshair()" style="margin-top: 10px;">
                            üéØ Reset to Center
                        </button>
                        <div class="toggle-switch" style="margin-top: 12px;">
                            <label class="switch">
                                <input type="checkbox" id="crosshair-calibration-enabled" onchange="toggleCrosshairCalibration()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Enable Crosshair Calibration</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Calibration Offset (px)</span>
                            <span id="crosshair-offset" class="stat-value">0, 0</span>
                        </div>
                        <button class="btn-secondary" onclick="resetCrosshairCalibration()" style="margin-top: 10px;">
                            üîÑ Reset Calibration
                        </button>
                        <div id="crosshair-calibration-status" class="status-message"></div>
                    </div>

                    <div class="control-group">
                        <h3>‚ö° Performance</h3>
                        <div class="stat-row">
                            <span class="stat-label">Frame Rate</span>
                            <span id="fps" class="stat-value">-- FPS</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Exposure Time</span>
                            <span id="exp-time" class="stat-value">--</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Analog Gain</span>
                            <span id="gain" class="stat-value">--</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Digital Gain</span>
                            <span id="digital-gain" class="stat-value">--</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>üõ†Ô∏è Motor Status</h3>
                        <div class="stat-row">
                            <span class="stat-label">X Motor</span>
                            <span class="stat-value"><span id="motor-x-dot" class="status-dot status-bad" title="Not initialized"></span></span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Y Motor</span>
                            <span class="stat-value"><span id="motor-y-dot" class="status-dot status-bad" title="Not initialized"></span></span>
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>üìü Stepper Diagnostics</h3>
                        <div class="stat-row">
                            <span class="stat-label">Microsteps</span>
                            <span id="controller-microsteps" class="stat-value">--</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Idle Remaining</span>
                            <span class="stat-value"><span id="idle-seconds-remaining">--</span></span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Active Moves</span>
                            <span id="idle-active-moves" class="stat-value">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Limit Switches</span>
                            <span class="stat-value" style="display:flex; gap:8px; align-items:center;">
                                <span title="X CW" id="ls-x-cw" class="status-dot status-ok"></span>
                                <span title="X CCW" id="ls-x-ccw" class="status-dot status-ok"></span>
                                <span title="Y CW" id="ls-y-cw" class="status-dot status-ok"></span>
                                <span title="Y CCW" id="ls-y-ccw" class="status-dot status-ok"></span>
                            </span>
                        </div>
                    </div>
                    <div class="control-group">
            <h3>üéöÔ∏è Motor Position</h3>
            <div class="position-row">
                <span class="stat-label">X</span>
                <div class="position-track">
                    <div class="position-center"></div>
                    <div id="pos-x-needle" class="position-needle"></div>
                </div>
                <span id="pos-x-value" class="stat-value">0</span>
            </div>
            <div class="position-row">
                <span class="stat-label">Y</span>
                <div class="position-track">
                    <div class="position-center"></div>
                    <div id="pos-y-needle" class="position-needle"></div>
                </div>
                <span id="pos-y-value" class="stat-value">0</span>
            </div>
        </div>
                </div>

                <!-- Camera Tracking Tab -->
                <div id="tracking-tab" class="tab-content">
                    <div class="control-group">
                        <h3>üìπ Tracking Mode</h3>
                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="tracking-mode-toggle" onchange="toggleTrackingMode()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Camera Mode (off = Crosshair Mode)</span>
                        </div>
                        <div id="tracking-mode-info" style="margin-top: 15px; padding: 12px; background: #e3f2fd; border-radius: 6px; font-size: 13px; color: #1565c0;">
                            <strong>Crosshair Mode:</strong> Tracks objects by moving the crosshair on screen. Camera stays fixed.
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>üéÆ Camera Control</h3>
                        
                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="camera-tracking-enabled" onchange="toggleCameraTracking()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Enable Camera Movement</span>
                        </div>

                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="camera-recenter-on-loss" onchange="toggleRecenterOnLoss()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Re-center camera slowly on target loss</span>
                        </div>

                        <button class="btn-primary" id="home-camera-btn" onclick="homeCameraPosition()" style="margin-top: 10px;">
                            üè† Home Camera to Center
                        </button>

                        <div style="margin-top: 15px; padding: 12px; background: #fff3cd; border-radius: 6px; font-size: 13px; color: #856404;">
                            <strong>‚ö†Ô∏è Important:</strong> Ensure stepper motors are properly connected before enabling camera tracking.
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>‚öôÔ∏è Camera Settings</h3>

                        <div class="slider-control">
                            <label>Dead Zone (pixels)</label>
                            <div class="slider-wrapper">
                                <input type="range" id="camera-dead-zone" min="5" max="100" value="20" step="5" oninput="updateCameraDeadZoneValue()">
                                <span id="camera-dead-zone-value" class="slider-value">20px</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>Movement Speed</label>
                            <div class="slider-wrapper">
                                <input type="range" id="camera-step-delay" min="0.0005" max="0.005" value="0.0045" step="0.0005" oninput="updateCameraStepDelayValue()">
                                <span id="camera-step-delay-value" class="slider-value">1.0ms</span>
                            </div>
                        </div>

                        <button class="btn-primary" onclick="applyCameraTrackingSettings()">Apply Settings</button>
                    </div>

                    <div class="control-group">
                        <h3>üß™ PID Tuning</h3>
                        <p style="color: #666; font-size: 13px; margin-bottom: 15px;">
                            Adjust PID gains for camera tracking responsiveness. Lower Ki is recommended to avoid drift.
                        </p>
                        <div class="slider-control">
                            <label>Kp</label>
                            <div class="slider-wrapper">
                                <input type="range" id="pid-kp" min="0" max="3" value="0.8" step="0.05" oninput="updatePIDLabel('kp')">
                                <span id="pid-kp-value" class="slider-value">0.80</span>
                            </div>
                        </div>
                        <div class="slider-control">
                            <label>Ki</label>
                            <div class="slider-wrapper">
                                <input type="range" id="pid-ki" min="0" max="0.5" value="0.0" step="0.005" oninput="updatePIDLabel('ki')">
                                <span id="pid-ki-value" class="slider-value">0.00</span>
                            </div>
                        </div>
                        <div class="slider-control">
                            <label>Kd</label>
                            <div class="slider-wrapper">
                                <input type="range" id="pid-kd" min="0" max="1.5" value="0.2" step="0.05" oninput="updatePIDLabel('kd')">
                                <span id="pid-kd-value" class="slider-value">0.20</span>
                            </div>
                        </div>
                        <button class="btn-primary" onclick="applyPID()">Apply PID</button>
                    </div>

                    <div class="control-group" style="background: #eef2ff; border: 1px dashed #c7d2fe; color: #4338ca;">
                        <h3>üéØ Manual Position Control</h3>
                        <p style="font-size: 13px; color: #4338ca;">
                            Manual aim controls now live on top of the live video so you can make adjustments while watching the feed. Use the arrow pad overlay to nudge the turret, tweak the step size slider, or jump home without losing sight of the target.
                        </p>
                    </div>

                    <div class="control-group">
                        <h3>üîß Calibration</h3>
                        <p style="color: #666; font-size: 13px; margin-bottom: 15px;">
                            Automatically find limits and set home position, or manually calibrate steps-per-pixel
                        </p>

                        <button class="btn-success" onclick="runAutoCalibration()" style="margin-bottom: 15px;">
                            ü§ñ Auto-Calibrate & Home
                        </button>

                        <div style="margin-bottom: 15px; padding: 10px; background: #e3f2fd; border-radius: 6px; font-size: 12px; color: #1565c0;">
                            <strong>Auto-Calibration:</strong> Finds movement limits in all directions, moves to center, and sets home position. May take several minutes.
                        </div>

                        <div class="slider-control">
                            <label>X-Axis Steps/Pixel</label>
                            <div class="slider-wrapper">
                                <input type="range" id="camera-x-steps-per-pixel" min="0.01" max="1.0" value="0.1" step="0.01" oninput="updateCameraXStepsValue()">
                                <span id="camera-x-steps-value" class="slider-value">0.10</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>Y-Axis Steps/Pixel</label>
                            <div class="slider-wrapper">
                                <input type="range" id="camera-y-steps-per-pixel" min="0.01" max="1.0" value="0.1" step="0.01" oninput="updateCameraYStepsValue()">
                                <span id="camera-y-steps-value" class="slider-value">0.10</span>
                            </div>
                        </div>

                        <button class="btn-primary" onclick="applyCameraCalibration()">Save Manual Calibration</button>
                    </div>

                    <div class="control-group">
                        <h3>üìä Camera Status</h3>
                        <div class="stat-row">
                            <span class="stat-label">System Status</span>
                            <span id="camera-system-status" class="stat-value">Initializing...</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Calibration Status</span>
                            <span id="camera-calibration-status" class="stat-value">Not Calibrated</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Camera Movement Enabled</span>
                            <span id="camera-enabled-status" class="stat-value">No</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Camera Position (X, Y)</span>
                            <span id="camera-position" class="stat-value">0, 0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Crosshair Position (X, Y)</span>
                            <span id="crosshair-position" class="stat-value">0, 0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Moving</span>
                            <span id="camera-moving" class="stat-value">No</span>
                        </div>
                    </div>
                </div>

                <!-- Laser Control Tab -->
                <div id="laser-tab" class="tab-content">
                    <div class="control-group">
                        <h3>üî¥ Laser System</h3>
                        
                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="laser-enabled" onchange="toggleLaser()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Enable Laser System</span>
                        </div>

                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="auto-fire-enabled" onchange="toggleAutoFire()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Auto-Fire on Detection</span>
                        </div>

                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="mock-fire-enabled" onchange="toggleMockFire()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Mock Fire Mode (Visual Only)</span>
                        </div>

                        <button id="fire-button" class="btn-success" data-fire-control onclick="fireLaser(this)" style="font-size: 16px; padding: 15px;">
                            üî¥ FIRE LASER
                        </button>
                    </div>

                    <div class="control-group">
                        <h3>‚öôÔ∏è Fire Settings</h3>

                        <div class="slider-control">
                            <label>Pulse Duration (ms)</label>
                            <div class="slider-wrapper">
                                <input type="range" id="pulse-duration" min="10" max="1000" value="100" step="10" oninput="updatePulseDurationValue()">
                                <span id="pulse-duration-value" class="slider-value">100ms</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>Burst Count</label>
                            <div class="slider-wrapper">
                                <input type="range" id="burst-count" min="1" max="10" value="1" step="1" oninput="updateBurstCountValue()">
                                <span id="burst-count-value" class="slider-value">1</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>Burst Delay (ms)</label>
                            <div class="slider-wrapper">
                                <input type="range" id="burst-delay" min="50" max="1000" value="100" step="50" oninput="updateBurstDelayValue()">
                                <span id="burst-delay-value" class="slider-value">100ms</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>Cooldown (seconds)</label>
                            <div class="slider-wrapper">
                                <input type="range" id="laser-cooldown" min="0.1" max="5" value="0.5" step="0.1" oninput="updateLaserCooldownValue()">
                                <span id="laser-cooldown-value" class="slider-value">0.5s</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>üí° Laser Power (%)</label>
                            <div class="slider-wrapper">
                                <input type="range" id="laser-power" min="0" max="100" value="100" step="5" oninput="updateLaserPowerValue()">
                                <span id="laser-power-value" class="slider-value">100%</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>üéØ Auto-Fire Distance (pixels)</label>
                            <div class="slider-wrapper">
                                <input type="range" id="auto-fire-distance" min="10" max="200" value="50" step="5" oninput="updateAutoFireDistanceValue()">
                                <span id="auto-fire-distance-value" class="slider-value">50px</span>
                            </div>
                        </div>

                        <button class="btn-primary" onclick="applyLaserSettings()">Apply Fire Settings</button>
                    </div>

                    <div class="control-group">
                        <h3>üìä Laser Status</h3>
                        <div class="stat-row">
                            <span class="stat-label">System Status</span>
                            <span id="laser-system-status" class="stat-value">OFF</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Mock Fire Mode</span>
                            <span id="laser-mock-mode" class="stat-value">OFF</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Ready to Fire</span>
                            <span id="laser-ready" class="stat-value">No</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Total Fires</span>
                            <span id="laser-fire-count" class="stat-value">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Cooldown</span>
                            <span id="laser-cooldown-remaining" class="stat-value">Ready</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Power Level</span>
                            <span id="laser-power-level" class="stat-value">100%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Hardware</span>
                            <span id="laser-hardware-status" class="stat-value">--</span>
                        </div>
                        <button class="btn-secondary" onclick="resetFireCount()" style="margin-top: 10px;">
                            üîÑ Reset Counter
                        </button>
                    </div>

                    <div id="laser-status-message" class="status-message"></div>
                </div>

                <!-- Presets Tab -->
                <div id="presets-tab" class="tab-content">
                    <div class="control-group">
                        <h3>üíæ Save Position</h3>
                        <p style="color: #666; font-size: 13px; margin-bottom: 15px;">
                            Save current crosshair position to a slot (1-10)
                        </p>
                        
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <input type="number" id="save-slot" min="1" max="10" value="1" 
                                   style="width: 60px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px;">
                            <input type="text" id="preset-label" placeholder="Label (optional)" 
                                   style="flex: 1; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px;">
                        </div>
                        <button class="btn-primary" onclick="savePreset()">üíæ Save to Slot</button>
                    </div>

                    <div class="control-group">
                        <h3>üìç Saved Positions</h3>
                        <div id="preset-list" style="max-height: 200px; overflow-y: auto;">
                            <p style="color: #999; text-align: center; padding: 20px;">No presets saved</p>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>üîÑ Pattern Sequence</h3>
                        <p style="color: #666; font-size: 13px; margin-bottom: 15px;">
                            Execute sequence of saved positions
                        </p>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; color: #555; font-weight: 600; margin-bottom: 8px; font-size: 13px;">
                                Sequence (comma-separated slots, e.g., 1,2,3,4)
                            </label>
                            <input type="text" id="pattern-sequence" placeholder="ex.: 1,2,3,4" 
                                   style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px;">
                        </div>

                        <div class="slider-control">
                            <label>Delay Between Positions (seconds)</label>
                            <div class="slider-wrapper">
                                <input type="range" id="pattern-delay" min="0.5" max="5" value="1" step="0.5" oninput="updatePatternDelayValue()">
                                <span id="pattern-delay-value" class="slider-value">1.0s</span>
                            </div>
                        </div>

                        <div class="toggle-switch" style="margin-bottom: 15px;">
                            <label class="switch">
                                <input type="checkbox" id="pattern-loop" checked>
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Loop Pattern</span>
                        </div>

                        <button id="start-pattern-btn" class="btn-success" onclick="startPattern()">
                            ‚ñ∂Ô∏è Start Pattern
                        </button>
                        <button id="stop-pattern-btn" class="btn-secondary" onclick="stopPattern()" style="display: none;">
                            ‚èπÔ∏è Stop Pattern
                        </button>
                    </div>

                    <div id="preset-status" class="status-message"></div>
                </div>

                <!-- Object Detection Tab -->
                <div id="object-tab" class="tab-content">
                    <div class="control-group">
                        <h3>üë§ Object Detection</h3>
                        
                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="object-enabled" onchange="toggleObjectDetection()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Enable Object Detection</span>
                        </div>

                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="object-auto-track-enabled" onchange="toggleObjectAutoTrack()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Auto-Track Objects</span>
                        </div>

                        <div class="select-control">
                            <label>Target Priority</label>
                            <select id="target-priority" onchange="applyObjectSettings()">
                                <option value="largest">Largest Object</option>
                                <option value="closest">Closest Object</option>
                                <option value="leftmost">Leftmost Object</option>
                                <option value="rightmost">Rightmost Object</option>
                            </select>
                        </div>

                        <div class="select-control">
                            <label>üî¨ Detection Method</label>
                            <select id="detection-method" onchange="switchDetectionMethod()">
                                <option value="haar">Haar Cascades (Fast, Faces Only)</option>
                                <option value="tflite">TensorFlow Lite (Accurate, 80+ Classes)</option>
                                <option value="roboflow">Roboflow Inference (Custom Models)</option>
                            </select>
                            <small style="color: #666; font-size: 11px; display: block; margin-top: 4px;" id="method-info">
                                Haar: 30+ FPS | TFLite: 15-25 FPS | Roboflow: Varies by network/model
                            </small>
                        </div>

                        <div id="haar-settings" style="display: none;">
            <div class="select-control">
                <label>Detection Mode</label>
                <select id="detection-mode" onchange="applyObjectSettings()">
                    <option value="face">Face Detection</option>
                    <option value="eye">Eye Detection</option>
                    <option value="body">Full Body Detection</option>
                    <option value="smile">Smile Detection</option>
                    <option value="balloon">Balloon Detection</option>
                </select>
            </div>
            <div id="balloon-settings" style="display: none; margin-top: 10px;">
                <h4 style="font-size: 14px; color: #333; margin-bottom: 8px;">üéà Balloon Tuning</h4>
                <div class="slider-control">
                    <label>Brightness Threshold (V 0-255)</label>
                    <div class="slider-wrapper">
                        <input type="range" id="balloon-v-threshold" min="0" max="255" value="60" step="5" oninput="updateBalloonVValue()">
                        <span id="balloon-v-value" class="slider-value">60</span>
                    </div>
                </div>
                <div class="slider-control">
                    <label>Minimum Area (pixels)</label>
                    <div class="slider-wrapper">
                        <input type="range" id="balloon-min-area" min="0" max="20000" value="2000" step="100" oninput="updateBalloonMinAreaValue()">
                        <span id="balloon-min-area-value" class="slider-value">2000</span>
                    </div>
                </div>
                <div class="slider-control">
                    <label>Min Circularity (0.00-1.00)</label>
                    <div class="slider-wrapper">
                        <input type="range" id="balloon-circularity" min="0" max="1" value="0.55" step="0.05" oninput="updateBalloonCircularityValue()">
                        <span id="balloon-circularity-value" class="slider-value">0.55</span>
                    </div>
                </div>
                <div class="slider-control">
                    <label>Min Fill Ratio (0.00-1.00)</label>
                    <div class="slider-wrapper">
                        <input type="range" id="balloon-fill" min="0" max="1" value="0.5" step="0.05" oninput="updateBalloonFillValue()">
                        <span id="balloon-fill-value" class="slider-value">0.50</span>
                    </div>
                </div>
                <div class="slider-control">
                    <label>Aspect Ratio Min (w/h)</label>
                    <div class="slider-wrapper">
                        <input type="range" id="balloon-ar-min" min="0" max="2" value="0.6" step="0.05" oninput="updateBalloonARMinValue()">
                        <span id="balloon-ar-min-value" class="slider-value">0.60</span>
                    </div>
                </div>
                <div class="slider-control">
                    <label>Aspect Ratio Max (w/h)</label>
                    <div class="slider-wrapper">
                        <input type="range" id="balloon-ar-max" min="0" max="3" value="1.6" step="0.05" oninput="updateBalloonARMaxValue()">
                        <span id="balloon-ar-max-value" class="slider-value">1.60</span>
                    </div>
                </div>
                <button class="btn-primary" onclick="applyBalloonSettings()">Apply Balloon Settings</button>
            </div>
        </div>

                        <div id="tflite-settings" style="display: none;">
                            <div class="slider-control">
                                <label>
                                    Confidence Threshold 
                                    <span id="tflite-confidence-value" style="color: #667eea;">0.5</span>
                                </label>
                                <input type="range" id="tflite-confidence" min="0.1" max="0.9" step="0.05" value="0.5" 
                                       oninput="updateTFLiteConfidence()">
                                <small style="color: #666; font-size: 11px;">Higher = fewer false positives</small>
                            </div>

                            <div class="input-control">
                                <label>Filter Classes (optional)</label>
                                <input type="text" id="tflite-filter-classes" 
                                       placeholder="e.g., person,cat,dog,bird"
                                       style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <small style="color: #666; font-size: 11px; display: block; margin-top: 4px;">
                                    Leave empty for all 80 classes
                                </small>
                            </div>

                            <button onclick="applyTFLiteSettings()" class="btn btn-primary" style="width: 100%; margin-top: 10px; padding: 10px; background: #667eea; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                Apply TFLite Settings
                            </button>
                        </div>

                        <div id="roboflow-settings" style="display: none;">
                            <div class="input-control" style="margin-bottom: 15px;">
                                <label>Server URL</label>
                                <input type="text" id="roboflow-server-url" 
                                       placeholder="http://192.168.1.100:9001"
                                       style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <small style="color: #666; font-size: 11px; display: block; margin-top: 4px;">
                                    IP address of the inference server
                                </small>
                            </div>

                            <div class="input-control" style="margin-bottom: 15px;">
                                <label>Model ID</label>
                                <input type="text" id="roboflow-model-id" 
                                       placeholder="project_id/version (e.g., soccer-players-5fuqs/1)"
                                       style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <small style="color: #666; font-size: 11px; display: block; margin-top: 4px;">
                                    Format: project_id/version. Find IDs in Roboflow (Project -> API)
                                </small>
                            </div>

                            <div class="input-control" style="margin-bottom: 15px;">
                                <label>API Key (optional)</label>
                                <input type="password" id="roboflow-api-key" 
                                       placeholder="Leave empty for public models"
                                       style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            </div>

                            <div class="slider-control">
                                <label>
                                    Confidence Threshold 
                                    <span id="roboflow-confidence-value" style="color: #667eea;">0.5</span>
                                </label>
                                <input type="range" id="roboflow-confidence" min="0.1" max="0.9" step="0.05" value="0.5" 
                                       oninput="updateRoboflowConfidence()">
                                <small style="color: #666; font-size: 11px;">Higher = fewer false positives</small>
                            </div>

                            <div class="input-control" style="margin-bottom: 15px;">
                                <label>Filter Classes (optional)</label>
                                <input type="text" id="roboflow-filter-classes" 
                                       placeholder="e.g., balloon"
                                       style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <small style="color: #666; font-size: 11px; display: block; margin-top: 4px;">
                                    Leave empty for all classes
                                </small>
                            </div>

                            <button onclick="applyRoboflowSettings()" class="btn btn-primary">
                                Apply Roboflow Settings
                            </button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>üìä Detection Status</h3>
                        <div class="stat-row">
                            <span class="stat-label">Status</span>
                            <span id="object-status" class="stat-value">OFF</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Method</span>
                            <span id="detection-method-display" class="stat-value">Haar Cascades</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Objects Detected</span>
                            <span id="objects-count" class="stat-value">0</span>
                        </div>
                        <div class="stat-row" id="current-mode-row">
                            <span class="stat-label">Current Mode</span>
                            <span id="current-mode" class="stat-value">Face</span>
                        </div>
                        <!-- TFLite Performance Stats -->
                        <div id="tflite-stats" style="display: none;">
                            <div class="stat-row">
                                <span class="stat-label">Inference Time</span>
                                <span id="tflite-inference-time" class="stat-value">--</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Est. FPS</span>
                                <span id="tflite-fps" class="stat-value">--</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Accelerator</span>
                                <span id="tflite-accelerator" class="stat-value">CPU</span>
                            </div>
                        </div>
                        <!-- Roboflow Performance Stats -->
                        <div id="roboflow-stats" style="display: none;">
                            <div class="stat-row">
                                <span class="stat-label">Server URL</span>
                                <span id="roboflow-server-display" class="stat-value">--</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Model ID</span>
                                <span id="roboflow-model-display" class="stat-value">--</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Inference Time</span>
                                <span id="roboflow-inference-time" class="stat-value">--</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Est. FPS</span>
                                <span id="roboflow-fps" class="stat-value">--</span>
                            </div>
                        </div>
                    </div>

                    <div id="object-status-message" class="status-message"></div>
                </div>

                <!-- Motion Detection Tab -->
                <div id="motion-tab" class="tab-content">
                    <div class="control-group">
                        <h3>üéØ Motion Detection</h3>
                        
                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="motion-enabled" onchange="toggleMotionDetection()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Enable Motion Detection</span>
                        </div>

                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="auto-track-enabled" onchange="toggleAutoTrack()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Auto-Track Motion</span>
                        </div>

                        <div class="slider-control">
                            <label>Sensitivity (Lower = More Sensitive)</label>
                            <div class="slider-wrapper">
                                <input type="range" id="motion-sensitivity" min="10" max="100" value="25" step="5" oninput="updateSensitivityValue()">
                                <span id="sensitivity-value" class="slider-value">25</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>Minimum Area (pixels)</label>
                            <div class="slider-wrapper">
                                <input type="range" id="motion-min-area" min="100" max="5000" value="500" step="100" oninput="updateMinAreaValue()">
                                <span id="min-area-value" class="slider-value">500</span>
                            </div>
                        </div>

                        <button class="btn-primary" onclick="applyMotionSettings()">Apply Settings</button>
                    </div>

                    <div class="control-group">
                        <h3>üìä Motion Status</h3>
                        <div class="stat-row">
                            <span class="stat-label">Detection</span>
                            <span id="motion-status" class="stat-value">OFF</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Motion Detected</span>
                            <span id="motion-detected" class="stat-value">No</span>
                        </div>
                    </div>

                    <div id="motion-status-message" class="status-message"></div>
                </div>

                <!-- Exposure Tab -->
                <div id="exposure-tab" class="tab-content">
                    <div class="control-group">
                        <h3>üîÜ Exposure Control</h3>
                        
                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="auto-exposure" checked onchange="toggleAutoExposure()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Auto Exposure</span>
                        </div>

                        <div id="manual-exposure-controls" style="display: none;">
                            <div class="slider-control">
                                <label>Exposure Time (¬µs)</label>
                                <div class="slider-wrapper">
                                    <input type="range" id="exposure-time" min="1000" max="200000" value="20000" step="1000" oninput="updateExposureValue()">
                                    <span id="exposure-time-value" class="slider-value">20000</span>
                                </div>
                            </div>

                            <div class="slider-control">
                                <label>Analog Gain</label>
                                <div class="slider-wrapper">
                                    <input type="range" id="analog-gain" min="1" max="16" value="1" step="0.1" oninput="updateAnalogGainValue()">
                                    <span id="analog-gain-value" class="slider-value">1.0</span>
                                </div>
                            </div>

                            <div class="slider-control">
                                <label>Digital Gain</label>
                                <div class="slider-wrapper">
                                    <input type="range" id="digital-gain" min="1" max="8" value="1" step="0.1" oninput="updateDigitalGainValue()">
                                    <span id="digital-gain-value" class="slider-value">1.0</span>
                                </div>
                            </div>

                            <button class="btn-primary" onclick="applyExposure()">Apply Exposure Settings</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>‚öñÔ∏è White Balance</h3>
                        
                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="auto-wb" checked onchange="toggleAutoWB()">
                                <span class="slider"></span>
                            </label>
                            <span class="toggle-label">Auto White Balance</span>
                        </div>

                        <div class="select-control" id="wb-mode-control" style="display: none;">
                            <label>WB Mode</label>
                            <select id="wb-mode" onchange="applyWhiteBalance()">
                                <option value="0">Auto</option>
                                <option value="1">Incandescent</option>
                                <option value="2">Tungsten</option>
                                <option value="3">Fluorescent</option>
                                <option value="4">Indoor</option>
                                <option value="5">Daylight</option>
                                <option value="6">Cloudy</option>
                            </select>
                        </div>
                    </div>

                    <div id="exposure-status" class="status-message"></div>
                </div>

                <!-- Image Tab -->
                <div id="image-tab" class="tab-content">
                    <div class="control-group">
                        <h3>üé® Image Adjustments</h3>

                        <div class="slider-control">
                            <label>Brightness</label>
                            <div class="slider-wrapper">
                                <input type="range" id="brightness" min="-1" max="1" value="0" step="0.1" oninput="updateBrightnessValue()">
                                <span id="brightness-value" class="slider-value">0.0</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>Contrast</label>
                            <div class="slider-wrapper">
                                <input type="range" id="contrast" min="0" max="2" value="1" step="0.1" oninput="updateContrastValue()">
                                <span id="contrast-value" class="slider-value">1.0</span>
                            </div>
                        </div>

                        <div class="slider-control">
                            <label>Saturation</label>
                            <div class="slider-wrapper">
                                <input type="range" id="saturation" min="0" max="2" value="1" step="0.1" oninput="updateSaturationValue()">
                                <span id="saturation-value" class="slider-value">1.0</span>
                            </div>
                        </div>

                        <button class="btn-primary" onclick="applyImageParams()">Apply Image Settings</button>
                        <button class="btn-secondary" onclick="resetImageParams()">Reset to Defaults</button>
                    </div>

                    <div id="image-status" class="status-message"></div>
                </div>

                <!-- Capture Tab -->
                <div id="capture-tab" class="tab-content">
                    <div class="control-group">
                        <h3>üì∏ Image Capture</h3>
                        <p style="color: #666; font-size: 13px; margin-bottom: 15px;">
                            Capture high-quality still images from the camera feed.
                        </p>
                        <button class="btn-success" onclick="captureImage()">üì∑ Capture Image</button>
                    </div>

                    <div id="capture-status" class="status-message"></div>

                    <div class="control-group">
                        <h3>üé• Video Recording</h3>
                        <p style="color: #666; font-size: 13px; margin-bottom: 15px;">
                            Record live video feed to MP4 file with timestamp.
                        </p>
                        
                        <div id="recording-info" style="display: none; margin-bottom: 15px;">
                            <div class="stat-row">
                                <span class="stat-label">Status</span>
                                <span class="stat-value" style="color: #dc3545;">‚óè Recording</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Duration</span>
                                <span id="recording-duration" class="stat-value">00:00</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Filename</span>
                                <span id="recording-filename" class="stat-value" style="font-size: 11px;">--</span>
                            </div>
                        </div>

                        <button id="start-recording-btn" class="btn-primary" onclick="startRecording()">
                            ‚è∫Ô∏è Start Recording
                        </button>
                        <button id="stop-recording-btn" class="btn-secondary" onclick="stopRecording()" style="display: none;">
                            ‚èπÔ∏è Stop Recording
                        </button>
                    </div>

                    <div id="recording-status" class="status-message"></div>
                </div>

            </div>
        </aside>
    </div>
</div>

    <script>
        const CAMERA_WIDTH = 1920;
        const CAMERA_HEIGHT = 1080;
        let crosshairCalibrationMode = false;

        // Editing guards to avoid UI snapping back during WebSocket updates
        const EDIT_IDLE_MS = 1500;
        let tfliteEditing = false;
        let tfliteLastEditTs = 0;
        let roboflowEditing = false;
        let roboflowLastEditTs = 0;
        let balloonEditing = false;
        let balloonLastEditTs = 0;
        let pidEditing = false;
        let pidLastEditTs = 0;

        // Tab switching
        function switchTab(tabName, buttonEl) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            const targetContent = document.getElementById(`${tabName}-tab`);
            if (targetContent) {
                targetContent.classList.add('active');
            }

            const targetButton = buttonEl || document.querySelector(`.tab[data-tab="${tabName}"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }

            // If leaving Object tab, make sure method-specific panels are hidden
            if (tabName !== 'object') {
                ['haar-settings','tflite-settings','roboflow-settings','current-mode-row','tflite-stats','roboflow-stats']
                    .forEach(id => { const el = document.getElementById(id); if (el) el.style.display = 'none'; });
            } else {
                // Refresh object status to show appropriate panel for selected method
                updateObjectStatus();
            }

        }

        // Crosshair positioning with camera movement support
        document.getElementById('video-stream').addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const scaleX = CAMERA_WIDTH / this.offsetWidth;
            const scaleY = CAMERA_HEIGHT / this.offsetHeight;
            const clickX = (e.clientX - rect.left);
            const clickY = (e.clientY - rect.top);
            const cameraX = Math.round(clickX * scaleX);
            const cameraY = Math.round(clickY * scaleY);
            
            if (crosshairCalibrationMode) {
                fetch('/crosshair/calibration/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: cameraX, y: cameraY })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('position').textContent = `X: ${data.absolute.x}, Y: ${data.absolute.y}`;
                        const off = data.offset;
                        document.getElementById('crosshair-offset').textContent = `${off.x}, ${off.y}`;
                        showStatus('crosshair-calibration-status', true, 'Calibration updated');
                    } else {
                        showStatus('crosshair-calibration-status', false, data.message || 'Failed to set calibration');
                    }
                })
                .catch(error => {
                    console.error('Error setting calibration:', error);
                    showStatus('crosshair-calibration-status', false, 'Failed to set calibration');
                });
                return;
            }

            // Check if camera tracking is enabled and active
            const trackingMode = document.getElementById('tracking-mode').value;
            const cameraTrackingEnabled = document.getElementById('camera-tracking-enabled').checked;
            
            if (trackingMode === 'camera' && cameraTrackingEnabled) {
                // Camera movement mode: move camera to recenter clicked position
                // Crosshair stays centered, don't update position display
                fetch('/tracking/camera/move_to_position', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: cameraX, y: cameraY })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Visual feedback
                        showStatus('tracking-status-message', true, 'Camera moving to recenter position...');
                    } else {
                        showStatus('tracking-status-message', false, data.message);
                    }
                })
                .catch(error => {
                    console.error('Error moving camera to position:', error);
                    showStatus('tracking-status-message', false, 'Failed to move camera');
                });
            } else {
                // Crosshair mode: update crosshair position
                document.getElementById('position').textContent = `X: ${cameraX}, Y: ${cameraY}`;
                fetch('/update_crosshair', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: cameraX, y: cameraY })
                });
            }
        });

        // Reset crosshair to center
        function resetCrosshair() {
            fetch('/reset_crosshair', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    document.getElementById('position').textContent = `X: ${data.x}, Y: ${data.y}`;
                }
            })
            .catch(error => console.error('Error resetting crosshair:', error));
        }

        function toggleCrosshairCalibration() {
            const enabled = document.getElementById('crosshair-calibration-enabled').checked;
            crosshairCalibrationMode = enabled;
            showStatus('crosshair-calibration-status', true, enabled ? 'Calibration mode ON. Click video to set default crosshair.' : 'Calibration mode OFF');
        }

        function resetCrosshairCalibration() {
            fetch('/crosshair/calibration/reset', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const off = data.offset || {x:0,y:0};
                    document.getElementById('crosshair-offset').textContent = `${off.x}, ${off.y}`;
                    document.getElementById('position').textContent = `X: ${data.absolute.x}, Y: ${data.absolute.y}`;
                    showStatus('crosshair-calibration-status', true, 'Calibration reset');
                } else {
                    showStatus('crosshair-calibration-status', false, data.message || 'Failed to reset calibration');
                }
            })
            .catch(error => {
                console.error('Error resetting calibration:', error);
                showStatus('crosshair-calibration-status', false, 'Failed to reset calibration');
            });
        }

        function updateCrosshairCalibration() {
            fetch('/crosshair/calibration')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.offset) {
                        document.getElementById('crosshair-offset').textContent = `${data.offset.x}, ${data.offset.y}`;
                    }
                })
                .catch(error => console.error('Error fetching crosshair calibration:', error));
        }

        // Exposure controls
        function toggleAutoExposure() {
            const autoEnabled = document.getElementById('auto-exposure').checked;
            document.getElementById('manual-exposure-controls').style.display = autoEnabled ? 'none' : 'block';
            fetch('/set_exposure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ auto: autoEnabled })
            })
            .then(response => response.json())
            .then(data => showStatus('exposure-status', data.status === 'success', 
                autoEnabled ? 'Auto exposure enabled' : 'Manual exposure mode'));
        }

        function updateExposureValue() {
            const value = document.getElementById('exposure-time').value;
            document.getElementById('exposure-time-value').textContent = value;
        }

        function updateAnalogGainValue() {
            const value = parseFloat(document.getElementById('analog-gain').value).toFixed(1);
            document.getElementById('analog-gain-value').textContent = value;
        }

        function updateDigitalGainValue() {
            const value = parseFloat(document.getElementById('digital-gain').value).toFixed(1);
            document.getElementById('digital-gain-value').textContent = value;
        }

        function applyExposure() {
            const exposureTime = parseInt(document.getElementById('exposure-time').value);
            const analogGain = parseFloat(document.getElementById('analog-gain').value);
            const digitalGain = parseFloat(document.getElementById('digital-gain').value);
            fetch('/set_exposure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    auto: false,
                    exposure_time: exposureTime,
                    analog_gain: analogGain,
                    digital_gain: digitalGain
                })
            })
            .then(response => response.json())
            .then(data => showStatus('exposure-status', data.status === 'success', 
                data.status === 'success' ? 'Exposure settings applied' : data.message));
        }

        // White balance controls
        function toggleAutoWB() {
            const autoEnabled = document.getElementById('auto-wb').checked;
            document.getElementById('wb-mode-control').style.display = autoEnabled ? 'none' : 'block';
            fetch('/set_white_balance', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ auto: autoEnabled })
            })
            .then(response => response.json())
            .then(data => showStatus('exposure-status', data.status === 'success',
                autoEnabled ? 'Auto white balance enabled' : 'Manual white balance mode'));
        }

        function applyWhiteBalance() {
            const mode = parseInt(document.getElementById('wb-mode').value);
            fetch('/set_white_balance', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ auto: false, mode: mode })
            })
            .then(response => response.json())
            .then(data => showStatus('exposure-status', data.status === 'success',
                data.status === 'success' ? 'White balance applied' : data.message));
        }

        // Image adjustment controls
        function updateBrightnessValue() {
            const value = parseFloat(document.getElementById('brightness').value).toFixed(1);
            document.getElementById('brightness-value').textContent = value;
        }

        function updateContrastValue() {
            const value = parseFloat(document.getElementById('contrast').value).toFixed(1);
            document.getElementById('contrast-value').textContent = value;
        }

        function updateSaturationValue() {
            const value = parseFloat(document.getElementById('saturation').value).toFixed(1);
            document.getElementById('saturation-value').textContent = value;
        }

        function applyImageParams() {
            const brightness = parseFloat(document.getElementById('brightness').value);
            const contrast = parseFloat(document.getElementById('contrast').value);
            const saturation = parseFloat(document.getElementById('saturation').value);
            fetch('/set_image_params', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    brightness: brightness,
                    contrast: contrast,
                    saturation: saturation
                })
            })
            .then(response => response.json())
            .then(data => showStatus('image-status', data.status === 'success',
                data.status === 'success' ? 'Image settings applied' : data.message));
        }

        function resetImageParams() {
            document.getElementById('brightness').value = 0;
            document.getElementById('contrast').value = 1;
            document.getElementById('saturation').value = 1;
            updateBrightnessValue();
            updateContrastValue();
            updateSaturationValue();
            applyImageParams();
        }

        // Image capture
        function captureImage() {
            fetch('/capture_image', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => showStatus('capture-status', data.status === 'success',
                data.status === 'success' ? `Image saved: ${data.filename}` : data.message));
        }

        // Status message display
        function showStatus(elementId, success, message) {
            const statusEl = document.getElementById(elementId);
            if (statusEl) {
                statusEl.className = 'status-message ' + (success ? 'status-success' : 'status-error');
                statusEl.textContent = message;
                statusEl.style.display = 'block';
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
            showToast(success, message, 3000);
        }

        function ensureToastContainer() {
            let container = document.getElementById('toast-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toast-container';
                container.className = 'toast-container';
                document.body.appendChild(container);
            }
            return container;
        }

        function showToast(success, message, duration = 3000) {
            const container = ensureToastContainer();
            const toast = document.createElement('div');
            toast.className = 'toast ' + (success ? 'toast-success' : 'toast-error');
            toast.textContent = message;
            container.appendChild(toast);

            setTimeout(() => {
                if (toast.parentNode === container) {
                    container.removeChild(toast);
                }
            }, Math.max(1000, duration));
        }

        // Video recording controls
        function startRecording() {
            fetch('/start_recording', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    document.getElementById('start-recording-btn').style.display = 'none';
                    document.getElementById('stop-recording-btn').style.display = 'block';
                    document.getElementById('recording-info').style.display = 'block';
                    document.getElementById('recording-filename').textContent = data.filename;
                    showStatus('recording-status', true, 'Recording started');
                } else {
                    showStatus('recording-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('recording-status', false, 'Failed to start recording');
                console.error('Error starting recording:', error);
            });
        }

        function stopRecording() {
            fetch('/stop_recording', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    document.getElementById('start-recording-btn').style.display = 'block';
                    document.getElementById('stop-recording-btn').style.display = 'none';
                    document.getElementById('recording-info').style.display = 'none';
                    const duration = data.duration ? `${Math.floor(data.duration)}s` : '';
                    showStatus('recording-status', true, 
                        `Recording saved: ${data.filename} (${duration})`);
                } else {
                    showStatus('recording-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('recording-status', false, 'Failed to stop recording');
                console.error('Error stopping recording:', error);
            });
        }



        function updateRecordingStatus() {
            fetch('/recording_status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.is_recording) {
                        // Update duration display
                        const duration = Math.floor(data.duration);
                        const minutes = Math.floor(duration / 60);
                        const seconds = duration % 60;
                        document.getElementById('recording-duration').textContent = 
                            `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        
                        // Ensure UI is in recording state
                        document.getElementById('start-recording-btn').style.display = 'none';
                        document.getElementById('stop-recording-btn').style.display = 'block';
                        document.getElementById('recording-info').style.display = 'block';
                        document.getElementById('recording-filename').textContent = data.filename;
                    }
                })
                .catch(error => console.error('Error checking recording status:', error));
        }

        // Laser control functions
        function toggleLaser() {
            const enabled = document.getElementById('laser-enabled').checked;
            fetch('/laser/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, 
                        enabled ? 'Laser system enabled' : 'Laser system disabled');
                    updateLaserStatus();
                } else {
                    showStatus('laser-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to toggle laser');
                console.error('Error toggling laser:', error);
            });
        }

        function toggleAutoFire() {
            const enabled = document.getElementById('auto-fire-enabled').checked;
            fetch('/laser/auto_fire', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, 
                        enabled ? 'Auto-fire enabled' : 'Auto-fire disabled');
                    updateLaserStatus();
                } else {
                    showStatus('laser-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to toggle auto-fire');
                console.error('Error toggling auto-fire:', error);
            });
        }

        function toggleMockFire() {
            const enabled = document.getElementById('mock-fire-enabled').checked;
            fetch('/laser/mock_fire', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, 
                        enabled ? 'Mock fire mode enabled - Visual feedback only' : 'Mock fire mode disabled');
                    updateLaserStatus();
                } else {
                    showStatus('laser-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to toggle mock fire');
                console.error('Error toggling mock fire:', error);
            });
        }

        function fireLaser(triggerButton) {
            const fireButtons = Array.from(document.querySelectorAll('[data-fire-control]'));

            if (triggerButton instanceof HTMLElement && !fireButtons.includes(triggerButton)) {
                fireButtons.push(triggerButton);
            }

            fireButtons.forEach(btn => btn.disabled = true);

            fetch('/laser/fire', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, data.message);
                    updateLaserStatus();
                } else {
                    showStatus('laser-status-message', false, data.message);
                    fireButtons.forEach(btn => btn.disabled = false);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to fire laser');
                console.error('Error firing laser:', error);
                fireButtons.forEach(btn => btn.disabled = false);
            });
        }

        function updatePulseDurationValue() {
            const value = document.getElementById('pulse-duration').value;
            document.getElementById('pulse-duration-value').textContent = value + 'ms';
        }

        function updateBurstCountValue() {
            const value = document.getElementById('burst-count').value;
            document.getElementById('burst-count-value').textContent = value;
        }

        function updateBurstDelayValue() {
            const value = document.getElementById('burst-delay').value;
            document.getElementById('burst-delay-value').textContent = value + 'ms';
        }

        function updateLaserCooldownValue() {
            const value = parseFloat(document.getElementById('laser-cooldown').value).toFixed(1);
            document.getElementById('laser-cooldown-value').textContent = value + 's';
        }

        function updateLaserPowerValue() {
            const value = parseInt(document.getElementById('laser-power').value);
            document.getElementById('laser-power-value').textContent = value + '%';
        }

        function updateAutoFireDistanceValue() {
            const value = parseInt(document.getElementById('auto-fire-distance').value);
            document.getElementById('auto-fire-distance-value').textContent = value + 'px';
        }

        function applyLaserSettings() {
            const pulseDuration = parseFloat(document.getElementById('pulse-duration').value) / 1000;
            const burstCount = parseInt(document.getElementById('burst-count').value);
            const burstDelay = parseFloat(document.getElementById('burst-delay').value) / 1000;
            const cooldown = parseFloat(document.getElementById('laser-cooldown').value);
            const power = parseInt(document.getElementById('laser-power').value);
            const autoFireDistance = parseInt(document.getElementById('auto-fire-distance').value);
            
            fetch('/laser/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    pulse_duration: pulseDuration,
                    burst_count: burstCount,
                    burst_delay: burstDelay,
                    cooldown: cooldown,
                    power: power,
                    auto_fire_distance_threshold: autoFireDistance
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, `Laser settings applied (Power: ${data.power}%)`);
                } else {
                    showStatus('laser-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to apply laser settings');
                console.error('Error applying laser settings:', error);
            });
        }

        function updateLaserStatus() {
            fetch('/laser/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('laser-system-status').textContent =
                            data.enabled ? 'ON' : 'OFF';
                        document.getElementById('laser-mock-mode').textContent =
                            data.mock_fire_mode ? 'ON (Visual Only)' : 'OFF';
                        document.getElementById('laser-ready').textContent =
                            data.ready_to_fire ? 'Yes' : 'No';
                        document.getElementById('laser-fire-count').textContent = 
                            data.fire_count;
                        
                        if (data.cooldown_remaining > 0) {
                            document.getElementById('laser-cooldown-remaining').textContent = 
                                data.cooldown_remaining.toFixed(1) + 's';
                        } else {
                            document.getElementById('laser-cooldown-remaining').textContent = 'Ready';
                        }
                        
                        // Display power level and hardware status
                        if (data.power !== undefined) {
                            document.getElementById('laser-power-level').textContent = data.power + '%';
                        }
                        document.getElementById('laser-hardware-status').textContent = 
                            data.hardware_available ? 'Connected' : 'Simulation';
                        
                        document.getElementById('laser-enabled').checked = data.enabled;
                        document.getElementById('auto-fire-enabled').checked = data.auto_fire;
                        document.getElementById('mock-fire-enabled').checked = data.mock_fire_mode || false;

                        // NOTE: Sliders are NOT synced from status updates (matches motion detection pattern)
                        // They are only synced on page load via syncLaserSliders()

                        const fireReady = data.ready_to_fire && data.enabled;
                        document.querySelectorAll('[data-fire-control]').forEach(btn => {
                            btn.disabled = !fireReady;
                        });

                        syncLaserOverlay(data);
                    }
                })
                .catch(error => console.error('Error fetching laser status:', error));
        }

        function resetFireCount() {
            if (!confirm('Reset fire counter to 0?')) return;
            
            fetch('/laser/reset_count', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, 'Fire counter reset');
                    updateLaserStatus();
                } else {
                    showStatus('laser-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to reset counter');
                console.error('Error resetting counter:', error);
            });
        }

        // Preset position controls
        function savePreset() {
            const slot = parseInt(document.getElementById('save-slot').value);
            const label = document.getElementById('preset-label').value || `Preset ${slot}`;
            
            fetch('/presets/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ slot: slot, label: label })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, `Saved to slot ${slot}`);
                    document.getElementById('preset-label').value = '';
                    loadPresetList();
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to save preset');
                console.error('Error saving preset:', error);
            });
        }

        function loadPreset(slot) {
            fetch(`/presets/load/${slot}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, `Loaded ${data.label}`);
                    document.getElementById('position').textContent = `X: ${data.position.x}, Y: ${data.position.y}`;
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to load preset');
                console.error('Error loading preset:', error);
            });
        }

        function deletePreset(slot) {
            if (!confirm(`Delete preset ${slot}?`)) return;
            
            fetch(`/presets/delete/${slot}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, `Deleted slot ${slot}`);
                    loadPresetList();
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to delete preset');
                console.error('Error deleting preset:', error);
            });
        }

        function loadPresetList() {
            fetch('/presets/list')
                .then(response => response.json())
                .then(data => {
                    const listEl = document.getElementById('preset-list');
                    const presets = data.presets;
                    
                    if (Object.keys(presets).length === 0) {
                        listEl.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">No presets saved</p>';
                        return;
                    }
                    
                    let html = '';
                    for (const [slot, preset] of Object.entries(presets).sort((a, b) => a[0] - b[0])) {
                        html += `
                            <div class="preset-item">
                                <div class="preset-info">
                                    <div><span class="preset-slot">#${slot}</span> <span class="preset-label">${preset.label}</span></div>
                                    <div class="preset-coords">X: ${preset.x}, Y: ${preset.y}</div>
                                </div>
                                <div class="preset-actions">
                                    <button class="preset-btn preset-btn-load" onclick="loadPreset(${slot})">Load</button>
                                    <button class="preset-btn preset-btn-delete" onclick="deletePreset(${slot})">Delete</button>
                                </div>
                            </div>
                        `;
                    }
                    listEl.innerHTML = html;
                })
                .catch(error => console.error('Error loading preset list:', error));
        }

        function updatePatternDelayValue() {
            const value = parseFloat(document.getElementById('pattern-delay').value).toFixed(1);
            document.getElementById('pattern-delay-value').textContent = value + 's';
        }

        function startPattern() {
            const sequenceStr = document.getElementById('pattern-sequence').value;
            const delay = parseFloat(document.getElementById('pattern-delay').value);
            const loop = document.getElementById('pattern-loop').checked;
            
            // Parse sequence
            const sequence = sequenceStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
            
            if (sequence.length === 0) {
                showStatus('preset-status', false, 'Enter a valid sequence');
                return;
            }
            
            fetch('/presets/pattern/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sequence: sequence, delay: delay, loop: loop })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, 'Pattern started');
                    document.getElementById('start-pattern-btn').style.display = 'none';
                    document.getElementById('stop-pattern-btn').style.display = 'block';
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to start pattern');
                console.error('Error starting pattern:', error);
            });
        }

        function stopPattern() {
            fetch('/presets/pattern/stop', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, 'Pattern stopped');
                    document.getElementById('start-pattern-btn').style.display = 'block';
                    document.getElementById('stop-pattern-btn').style.display = 'none';
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to stop pattern');
                console.error('Error stopping pattern:', error);
            });
        }

        function updatePatternStatus() {
            fetch('/presets/pattern/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.running) {
                        document.getElementById('start-pattern-btn').style.display = 'none';
                        document.getElementById('stop-pattern-btn').style.display = 'block';
                    } else {
                        document.getElementById('start-pattern-btn').style.display = 'block';
                        document.getElementById('stop-pattern-btn').style.display = 'none';
                    }
                })
                .catch(error => console.error('Error checking pattern status:', error));
        }

        // Keyboard shortcuts for presets (1-9, 0 for slot 10)
        document.addEventListener('keydown', function(e) {
            // Only trigger if not typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const key = e.key;
            if (key >= '1' && key <= '9') {
                const slot = parseInt(key);
                loadPreset(slot);
                e.preventDefault();
            } else if (key === '0') {
                loadPreset(10);
                e.preventDefault();
            }
        });

        // Object detection controls
        function toggleObjectDetection() {
            const enabled = document.getElementById('object-enabled').checked;
            fetch('/object_detection/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 
                        enabled ? 'Object detection enabled' : 'Object detection disabled');
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to toggle object detection');
                console.error('Error toggling object detection:', error);
            });
        }

        function toggleObjectAutoTrack() {
            const enabled = document.getElementById('object-auto-track-enabled').checked;
            fetch('/object_detection/auto_track', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true,
                        enabled ? 'Object auto-tracking enabled' : 'Object auto-tracking disabled');
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to toggle object auto-track');
                console.error('Error toggling object auto-track:', error);
            });
        }

        function applyObjectSettings() {
            const mode = document.getElementById('detection-mode').value;
            const priority = document.getElementById('target-priority').value;
            // Update balloon settings visibility immediately
            showHideBalloonSettings();
            
            fetch('/object_detection/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    mode: mode,
                    priority: priority
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 'Object detection settings applied');
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to apply object settings');
                console.error('Error applying object settings:', error);
            });
        }

        function switchDetectionMethod() {
            const method = document.getElementById('detection-method').value;
            
            // Show/hide method-specific settings
            const haarSettings = document.getElementById('haar-settings');
            const tfliteSettings = document.getElementById('tflite-settings');
            const roboflowSettings = document.getElementById('roboflow-settings');
            const currentModeRow = document.getElementById('current-mode-row');
            const tfliteStats = document.getElementById('tflite-stats');
            const roboflowStats = document.getElementById('roboflow-stats');
            const balloonSettings = document.getElementById('balloon-settings');
            
            // Hide all first
            haarSettings.style.display = 'none';
            tfliteSettings.style.display = 'none';
            roboflowSettings.style.display = 'none';
            tfliteStats.style.display = 'none';
            roboflowStats.style.display = 'none';
            if (balloonSettings) balloonSettings.style.display = 'none';
            
            if (method === 'haar') {
                haarSettings.style.display = 'block';
                currentModeRow.style.display = 'flex';
                document.getElementById('detection-method-display').textContent = 'Haar Cascades';
                showHideBalloonSettings();
            } else if (method === 'tflite') {
                tfliteSettings.style.display = 'block';
                currentModeRow.style.display = 'none';
                tfliteStats.style.display = 'block';
                document.getElementById('detection-method-display').textContent = 'TensorFlow Lite';
            } else if (method === 'roboflow') {
                roboflowSettings.style.display = 'block';
                currentModeRow.style.display = 'none';
                roboflowStats.style.display = 'block';
                document.getElementById('detection-method-display').textContent = 'Roboflow Inference';
            }
            
            syncOverlayConfidenceFromMain();

            // Switch method on server
            fetch('/detection_method/switch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ method: method })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const methodNames = {
                        'haar': 'Haar Cascades',
                        'tflite': 'TensorFlow Lite',
                        'roboflow': 'Roboflow Inference'
                    };
                    showStatus('object-status-message', true, 
                        `Switched to ${methodNames[method] || method}`);
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                    // Revert on failure
                    document.getElementById('detection-method').value = 
                        data.detection_method || 'haar';
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to switch detection method');
                console.error('Error switching detection method:', error);
            });
        }

        function updateTFLiteConfidence() {
            const value = document.getElementById('tflite-confidence').value;
            document.getElementById('tflite-confidence-value').textContent = value;
            tfliteLastEditTs = Date.now();
            tfliteEditing = true;
        }

        function applyTFLiteSettings() {
            const confidence = parseFloat(document.getElementById('tflite-confidence').value);
            const filterClasses = document.getElementById('tflite-filter-classes').value;
            
            fetch('/tflite/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    confidence: confidence,
                    filter_classes: filterClasses
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 
                        `TFLite settings applied - Confidence: ${data.confidence.toFixed(2)}`);
                    tfliteEditing = false;
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to apply TFLite settings');
                console.error('Error applying TFLite settings:', error);
            });
        }

        function updateRoboflowConfidence() {
            const value = document.getElementById('roboflow-confidence').value;
            document.getElementById('roboflow-confidence-value').textContent = value;
            roboflowLastEditTs = Date.now();
            roboflowEditing = true;
        }

        function applyRoboflowSettings() {
            const serverUrl = document.getElementById('roboflow-server-url').value;
            const modelId = document.getElementById('roboflow-model-id').value;
            const apiKey = document.getElementById('roboflow-api-key').value;
            const confidence = parseFloat(document.getElementById('roboflow-confidence').value);
            const filterClasses = document.getElementById('roboflow-filter-classes').value;
            
            fetch('/roboflow/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    server_url: serverUrl || undefined,
                    model_id: modelId || undefined,
                    api_key: apiKey || undefined,
                    confidence: confidence,
                    filter_classes: filterClasses
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 
                        `Roboflow settings applied - Confidence: ${data.confidence ? data.confidence.toFixed(2) : 'N/A'}`);
                    roboflowEditing = false;
                    // Switch to Roboflow method after applying settings
                    fetch('/detection_method/switch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ method: 'roboflow' })
                    })
                    .then(r => r.json())
                    .then(sw => {
                        if (sw.status === 'success') {
                            document.getElementById('detection-method').value = 'roboflow';
                            updateObjectStatus();
                        } else {
                            showStatus('object-status-message', false, sw.message || 'Failed to switch to Roboflow');
                        }
                    })
                    .catch(err => {
                        console.error('Error switching to Roboflow:', err);
                    });
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to apply Roboflow settings');
                console.error('Error applying Roboflow settings:', error);
            });
        }

        function updateObjectStatus() {
            fetch('/object_detection/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('object-status').textContent = 
                            data.enabled ? 'ON' : 'OFF';
                        document.getElementById('objects-count').textContent = 
                            data.objects_detected;
                        
                        // Update detection method
                        const method = data.detection_method || 'haar';
                        document.getElementById('detection-method').value = method;
                        
                        // Show/hide appropriate settings
                        const haarSettings = document.getElementById('haar-settings');
                        const tfliteSettings = document.getElementById('tflite-settings');
                        const roboflowSettings = document.getElementById('roboflow-settings');
                        const currentModeRow = document.getElementById('current-mode-row');
                        const tfliteStats = document.getElementById('tflite-stats');
                        const roboflowStats = document.getElementById('roboflow-stats');
                        const balloonSettings = document.getElementById('balloon-settings');
                        
                        // Hide all first
                        haarSettings.style.display = 'none';
                        tfliteSettings.style.display = 'none';
                        roboflowSettings.style.display = 'none';
                        tfliteStats.style.display = 'none';
                        roboflowStats.style.display = 'none';
                        if (balloonSettings) balloonSettings.style.display = 'none';
                        
                        if (method === 'haar') {
                            haarSettings.style.display = 'block';
                            currentModeRow.style.display = 'flex';
                            document.getElementById('detection-method-display').textContent = 'Haar Cascades';
                            document.getElementById('current-mode').textContent = 
                                data.mode.charAt(0).toUpperCase() + data.mode.slice(1);
                            document.getElementById('detection-mode').value = data.mode;
                            // Sync balloon sliders from status
                            const bs = data.balloon_settings || {};
                            if (document.getElementById('balloon-v-threshold')) {
                                const now = Date.now();
                                const allowBalloonSync = !balloonEditing || (now - balloonLastEditTs > EDIT_IDLE_MS);
                                if (allowBalloonSync) {
                                    document.getElementById('balloon-v-threshold').value = bs.v_threshold ?? 60;
                                    document.getElementById('balloon-v-value').textContent = bs.v_threshold ?? 60;
                                    document.getElementById('balloon-min-area').value = bs.min_area ?? 2000;
                                    document.getElementById('balloon-min-area-value').textContent = bs.min_area ?? 2000;
                                    document.getElementById('balloon-circularity').value = bs.circularity_min ?? 0.55;
                                    document.getElementById('balloon-circularity-value').textContent = (bs.circularity_min ?? 0.55).toFixed(2);
                                    document.getElementById('balloon-fill').value = bs.fill_ratio_min ?? 0.5;
                                    document.getElementById('balloon-fill-value').textContent = (bs.fill_ratio_min ?? 0.5).toFixed(2);
                                    document.getElementById('balloon-ar-min').value = bs.aspect_ratio_min ?? 0.6;
                                    document.getElementById('balloon-ar-min-value').textContent = (bs.aspect_ratio_min ?? 0.6).toFixed(2);
                                    document.getElementById('balloon-ar-max').value = bs.aspect_ratio_max ?? 1.6;
                                    document.getElementById('balloon-ar-max-value').textContent = (bs.aspect_ratio_max ?? 1.6).toFixed(2);
                                    showHideBalloonSettings();
                                }
                            }
                        } else if (method === 'tflite') {
                            tfliteSettings.style.display = 'block';
                            currentModeRow.style.display = 'none';
                            tfliteStats.style.display = 'block';
                            document.getElementById('detection-method-display').textContent = 'TensorFlow Lite';
                            
                            // Update TFLite stats if available
                            if (data.tflite_stats) {
                                const stats = data.tflite_stats;
                                document.getElementById('tflite-inference-time').textContent = 
                                    stats.avg_inference_ms.toFixed(1) + ' ms';
                                document.getElementById('tflite-fps').textContent = 
                                    stats.estimated_fps.toFixed(1) + ' FPS';
                                document.getElementById('tflite-accelerator').textContent = 
                                    stats.accelerator;
                                
                                if (stats.confidence_threshold !== undefined) {
                                    const now = Date.now();
                                    const allowTFLiteSync = !tfliteEditing || (now - tfliteLastEditTs > EDIT_IDLE_MS);
                                    if (allowTFLiteSync) {
                                        document.getElementById('tflite-confidence').value = stats.confidence_threshold;
                                        document.getElementById('tflite-confidence-value').textContent = 
                                            stats.confidence_threshold.toFixed(2);
                                    }
                                }
                            }
                        } else if (method === 'roboflow') {
                            roboflowSettings.style.display = 'block';
                            currentModeRow.style.display = 'none';
                            roboflowStats.style.display = 'block';
                            document.getElementById('detection-method-display').textContent = 'Roboflow Inference';
                            
                            // Update Roboflow stats if available
                            if (data.roboflow_stats) {
                                const stats = data.roboflow_stats;
                                document.getElementById('roboflow-server-display').textContent = 
                                    stats.server_url || '--';
                                document.getElementById('roboflow-model-display').textContent = 
                                    stats.model_id || '--';
                                document.getElementById('roboflow-inference-time').textContent = 
                                    stats.avg_inference_ms ? stats.avg_inference_ms.toFixed(1) + ' ms' : '--';
                                document.getElementById('roboflow-fps').textContent = 
                                    stats.estimated_fps ? stats.estimated_fps.toFixed(1) + ' FPS' : '--';
                                
                                const now = Date.now();
                                const allowRoboflowSync = !roboflowEditing || (now - roboflowLastEditTs > EDIT_IDLE_MS);
                                if (allowRoboflowSync) {
                                    // Populate form fields with current settings
                                    if (stats.server_url) {
                                        document.getElementById('roboflow-server-url').value = stats.server_url;
                                    }
                                    if (stats.model_id) {
                                        document.getElementById('roboflow-model-id').value = stats.model_id;
                                    }
                                    if (stats.confidence !== undefined) {
                                        document.getElementById('roboflow-confidence').value = stats.confidence;
                                        document.getElementById('roboflow-confidence-value').textContent = 
                                            stats.confidence.toFixed(2);
                                    }
                                    if (stats.class_filter && stats.class_filter.length > 0) {
                                        document.getElementById('roboflow-filter-classes').value = 
                                            stats.class_filter.join(',');
                                    }
                                }
                                // Reflect API key presence without exposing it
                                const apiKeyInput = document.getElementById('roboflow-api-key');
                                if (apiKeyInput) {
                                    if (stats.api_key_set) {
                                        apiKeyInput.placeholder = 'Saved (hidden)';
                                        apiKeyInput.value = '';
                                    } else {
                                        apiKeyInput.placeholder = 'Leave empty for public models';
                                    }
                                }
                            }
                        }
                        
                        // Sync UI with server state
                        document.getElementById('object-enabled').checked = data.enabled;
                        document.getElementById('object-auto-track-enabled').checked = data.auto_track;
                        document.getElementById('target-priority').value = data.priority;

                        const detectBtn = document.getElementById('overlay-objects-detect');
                        if (detectBtn) detectBtn.classList.toggle('active', !!data.enabled);
                        const trackBtn = document.getElementById('overlay-objects-track');
                        if (trackBtn) trackBtn.classList.toggle('active', !!data.auto_track);
                        syncOverlayConfidenceFromMain();
                    }
                })
                .catch(error => console.error('Error fetching object status:', error));
        }

        // Balloon UI helpers
        function showHideBalloonSettings() {
            const method = document.getElementById('detection-method').value;
            const modeEl = document.getElementById('detection-mode');
            const mode = modeEl ? modeEl.value : 'face';
            const balloonSettings = document.getElementById('balloon-settings');
            if (!balloonSettings) return;
            if (method === 'haar' && mode === 'balloon') {
                balloonSettings.style.display = 'block';
            } else {
                balloonSettings.style.display = 'none';
            }
        }

        function updateBalloonVValue() {
            const v = document.getElementById('balloon-v-threshold').value;
            document.getElementById('balloon-v-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonMinAreaValue() {
            const v = document.getElementById('balloon-min-area').value;
            document.getElementById('balloon-min-area-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonCircularityValue() {
            const v = parseFloat(document.getElementById('balloon-circularity').value).toFixed(2);
            document.getElementById('balloon-circularity-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonFillValue() {
            const v = parseFloat(document.getElementById('balloon-fill').value).toFixed(2);
            document.getElementById('balloon-fill-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonARMinValue() {
            const v = parseFloat(document.getElementById('balloon-ar-min').value).toFixed(2);
            document.getElementById('balloon-ar-min-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonARMaxValue() {
            const v = parseFloat(document.getElementById('balloon-ar-max').value).toFixed(2);
            document.getElementById('balloon-ar-max-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }

        function applyBalloonSettings() {
            const payload = {
                v_threshold: parseInt(document.getElementById('balloon-v-threshold').value),
                min_area: parseInt(document.getElementById('balloon-min-area').value),
                circularity_min: parseFloat(document.getElementById('balloon-circularity').value),
                fill_ratio_min: parseFloat(document.getElementById('balloon-fill').value),
                aspect_ratio_min: parseFloat(document.getElementById('balloon-ar-min').value),
                aspect_ratio_max: parseFloat(document.getElementById('balloon-ar-max').value)
            };
            fetch('/balloon/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 'Balloon settings applied');
                    balloonEditing = false;
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to apply balloon settings');
                console.error('Error applying balloon settings:', error);
            });
        }

        // Motion detection controls
        function toggleMotionDetection() {
            const enabled = document.getElementById('motion-enabled').checked;
            fetch('/motion_detection/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('motion-status-message', true, 
                        enabled ? 'Motion detection enabled' : 'Motion detection disabled');
                    updateMotionStatus();
                } else {
                    showStatus('motion-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('motion-status-message', false, 'Failed to toggle motion detection');
                console.error('Error toggling motion detection:', error);
            });
        }

        function toggleAutoTrack() {
            const enabled = document.getElementById('auto-track-enabled').checked;
            fetch('/motion_detection/auto_track', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('motion-status-message', true, 
                        enabled ? 'Auto-tracking enabled' : 'Auto-tracking disabled');
                } else {
                    showStatus('motion-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('motion-status-message', false, 'Failed to toggle auto-track');
                console.error('Error toggling auto-track:', error);
            });
        }

        function updateSensitivityValue() {
            const value = document.getElementById('motion-sensitivity').value;
            document.getElementById('sensitivity-value').textContent = value;
        }

        function updateMinAreaValue() {
            const value = document.getElementById('motion-min-area').value;
            document.getElementById('min-area-value').textContent = value;
        }

        function applyMotionSettings() {
            const sensitivity = parseInt(document.getElementById('motion-sensitivity').value);
            const minArea = parseInt(document.getElementById('motion-min-area').value);
            
            fetch('/motion_detection/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sensitivity: sensitivity,
                    min_area: minArea
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('motion-status-message', true, 'Motion settings applied');
                    syncMotionSliders(); // Sync sliders after successful apply
                } else {
                    showStatus('motion-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('motion-status-message', false, 'Failed to apply motion settings');
                console.error('Error applying motion settings:', error);
            });
        }

        function updateMotionStatus() {
            fetch('/motion_detection/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('motion-status').textContent = 
                            data.enabled ? 'ON' : 'OFF';
                        document.getElementById('motion-detected').textContent = 
                            data.motion_detected ? 'Yes' : 'No';
                        
                        // Sync toggles with server state
                        document.getElementById('motion-enabled').checked = data.enabled;
                        document.getElementById('auto-track-enabled').checked = data.auto_track;
                        
                        // Don't sync sliders here - let user adjust them before applying
                        // Only sync sliders on page load or after applying settings
                    }
                })
                .catch(error => console.error('Error fetching motion status:', error));
        }
        
        function syncMotionSliders() {
            // Sync motion sliders with server state (called on page load only)
            fetch('/motion_detection/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('motion-sensitivity').value = data.sensitivity;
                        document.getElementById('motion-min-area').value = data.min_area;
                        updateSensitivityValue();
                        updateMinAreaValue();
                    }
                })
                .catch(error => console.error('Error fetching motion status:', error));
        }
        
        function syncLaserSliders() {
            // Sync laser sliders with server state (called on page load only)
            fetch('/laser/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('pulse-duration').value = data.pulse_duration * 1000;
                        document.getElementById('burst-count').value = data.burst_count;
                        document.getElementById('burst-delay').value = data.burst_delay * 1000;
                        document.getElementById('laser-cooldown').value = data.cooldown;
                        if (data.power !== undefined) {
                            document.getElementById('laser-power').value = data.power;
                        }
                        if (data.auto_fire_distance_threshold !== undefined) {
                            document.getElementById('auto-fire-distance').value = data.auto_fire_distance_threshold;
                        }
                        updatePulseDurationValue();
                        updateBurstCountValue();
                        updateBurstDelayValue();
                        updateLaserCooldownValue();
                        updateLaserPowerValue();
                        updateAutoFireDistanceValue();
                    }
                })
                .catch(error => console.error('Error syncing laser sliders:', error));
        }

        // Update crosshair position display
        function updateCrosshairPosition() {
            fetch('/get_crosshair_position')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('crosshair-position').textContent = 
                            `${data.relative_x}, ${data.relative_y}`;
                    }
                })
                .catch(error => console.error('Error fetching crosshair position:', error));
        }

        // Update stats periodically
        function updateStats() {
            fetch('/exposure_stats')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('exp-time').textContent = 
                        `${(data.exposure_time/1000).toFixed(1)} ms`;
                    document.getElementById('gain').textContent = 
                        `${data.analog_gain.toFixed(2)}x`;
                });

            fetch('/get_fps')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('fps').textContent = `${data.fps} FPS`;
                });

            fetch('/get_camera_settings')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('digital-gain').textContent = 
                            `${data.settings.digital_gain.toFixed(2)}x`;
                    }
                });
            
            // Update recording status if on capture tab
            updateRecordingStatus();
            
            // Update laser status
            updateLaserStatus();
            
            // Update object detection status
            updateObjectStatus();
            
            // Update motion detection status
            updateMotionStatus();
            
            // Update pattern status
            updatePatternStatus();
            
            // Update crosshair position
            updateCrosshairPosition();
            updateCrosshairCalibration();
        }

        // Camera tracking controls
        function toggleTrackingMode() {
            const checkbox = document.getElementById('tracking-mode-toggle');
            const mode = checkbox && checkbox.checked ? 'camera' : 'crosshair';
            fetch('/tracking/mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    updateTrackingModeUI(mode);
                    showStatus('tracking-status-message', true, mode === 'camera' ? 'Camera tracking mode active' : 'Crosshair tracking mode active');
                    updateCameraTrackingStatus();
                } else {
                    showStatus('tracking-status-message', false, data.message || 'Failed to set tracking mode');
                    if (checkbox) checkbox.checked = !checkbox.checked;
                }
            })
            .catch(error => {
                console.error('Error setting tracking mode:', error);
                showStatus('tracking-status-message', false, 'Failed to set tracking mode');
                if (checkbox) checkbox.checked = !checkbox.checked;
            });
        }

        function updateTrackingModeUI(mode) {
            const cameraControls = document.getElementById('camera-tracking-controls');
            const infoBox = document.getElementById('tracking-mode-info');
            
            if (mode === 'camera') {
                cameraControls.style.display = 'block';
                infoBox.innerHTML = '<strong>Camera Mode:</strong> Physically moves the camera with stepper motors to keep objects centered. Crosshair stays fixed.';
                infoBox.style.background = '#fff3cd';
                infoBox.style.color = '#856404';
            } else {
                cameraControls.style.display = 'none';
                infoBox.innerHTML = '<strong>Crosshair Mode:</strong> Tracks objects by moving the crosshair on screen. Camera stays fixed.';
                infoBox.style.background = '#e3f2fd';
                infoBox.style.color = '#1565c0';
            }
        }

        function toggleCameraTracking() {
            const enabled = document.getElementById('camera-tracking-enabled').checked;
            
            fetch('/tracking/camera/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 
                        enabled ? 'Camera tracking enabled' : 'Camera tracking disabled');
                    updateCameraTrackingStatus();
                } else {
                    showStatus('tracking-status-message', false, data.message);
                    document.getElementById('camera-tracking-enabled').checked = !enabled;
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to toggle camera tracking');
                console.error('Error toggling camera tracking:', error);
                document.getElementById('camera-tracking-enabled').checked = !enabled;
            });
        }

        function toggleRecenterOnLoss() {
            const enabled = document.getElementById('camera-recenter-on-loss').checked;
            fetch('/tracking/camera/recenter_on_loss', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, enabled ? 'Re-center on loss enabled' : 'Re-center on loss disabled');
                } else {
                    showStatus('tracking-status-message', false, data.message);
                    document.getElementById('camera-recenter-on-loss').checked = !enabled;
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to set re-center on loss');
                console.error('Error toggling re-center on loss:', error);
                document.getElementById('camera-recenter-on-loss').checked = !enabled;
            });
        }

        function homeCameraPosition() {
            fetch('/tracking/camera/home', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 'Homing camera to center position...');
                    setTimeout(updateCameraTrackingStatus, 1000);
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to home camera');
                console.error('Error homing camera:', error);
            });
        }

        function updateCameraDeadZoneValue() {
            const value = document.getElementById('camera-dead-zone').value;
            document.getElementById('camera-dead-zone-value').textContent = value + 'px';
        }

        function updateCameraStepDelayValue() {
            const sliderValue = parseFloat(document.getElementById('camera-step-delay').value);
            // Invert slider: higher slider value = lower delay (faster)
            const actualDelay = 0.0055 - sliderValue;
            document.getElementById('camera-step-delay-value').textContent = (actualDelay * 1000).toFixed(1) + 'ms';
        }

        // Track whether calibration sliders have been initialized from server
        let calibrationSlidersInitialized = false;

        function updateCameraXStepsValue() {
            const value = parseFloat(document.getElementById('camera-x-steps-per-pixel').value).toFixed(2);
            document.getElementById('camera-x-steps-value').textContent = value;
        }

        function updateCameraYStepsValue() {
            const value = parseFloat(document.getElementById('camera-y-steps-per-pixel').value).toFixed(2);
            document.getElementById('camera-y-steps-value').textContent = value;
        }

        function applyCameraTrackingSettings() {
            const deadZone = parseInt(document.getElementById('camera-dead-zone').value);
            const sliderValue = parseFloat(document.getElementById('camera-step-delay').value);
            // Invert slider: higher slider value = lower delay (faster)
            const stepDelay = 0.0055 - sliderValue;
            
            fetch('/tracking/camera/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    dead_zone_pixels: deadZone,
                    step_delay: stepDelay
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 'Camera tracking settings applied');
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to apply settings');
                console.error('Error applying camera settings:', error);
            });
        }

        function updatePIDLabel(kind) {
            const el = document.getElementById(`pid-${kind}`);
            const val = parseFloat(el.value);
            const label = document.getElementById(`pid-${kind}-value`);
            if (label) label.textContent = val.toFixed(2);
            pidEditing = true;
            pidLastEditTs = Date.now();
        }

        function applyPID() {
            const kp = parseFloat(document.getElementById('pid-kp').value);
            const ki = parseFloat(document.getElementById('pid-ki').value);
            const kd = parseFloat(document.getElementById('pid-kd').value);
            fetch('/tracking/camera/pid', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ kp: kp, ki: ki, kd: kd })
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 'PID settings applied');
                    pidEditing = false;
                } else {
                    showStatus('tracking-status-message', false, data.message || 'Failed to apply PID');
                }
            })
            .catch(err => {
                console.error('Error applying PID:', err);
                showStatus('tracking-status-message', false, 'Failed to apply PID');
            });
        }

        function applyCameraCalibration() {
            const xSteps = parseFloat(document.getElementById('camera-x-steps-per-pixel').value);
            const ySteps = parseFloat(document.getElementById('camera-y-steps-per-pixel').value);
            
            fetch('/tracking/camera/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    x_steps_per_pixel: xSteps,
                    y_steps_per_pixel: ySteps
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 'Calibration saved');
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to save calibration');
                console.error('Error saving calibration:', error);
            });
        }

        let overlayConfidenceTimeout = null;

        function toggleOverlayPanel(panelId, button) {
            const panel = document.getElementById(panelId);
            if (!panel) return;
            const isActive = panel.classList.contains('active');
            panel.classList.toggle('active', !isActive);
            if (button) {
                button.classList.toggle('active', !isActive);
            } else {
                const key = panel.dataset.overlayKey;
                if (key) {
                    const toggleBtn = document.querySelector(`.toolbar-button[data-overlay-target="${key}"]`);
                    if (toggleBtn) {
                        toggleBtn.classList.toggle('active', panel.classList.contains('active'));
                    }
                }
            }
        }

        function toggleMotorsFromToolbar() {
            const toggle = document.getElementById('camera-tracking-enabled');
            if (!toggle) return;
            toggle.checked = !toggle.checked;
            toggleCameraTracking();
        }

        function syncMotorsToolbar(enabled) {
            const stateEl = document.getElementById('motors-state');
            if (stateEl) {
                stateEl.textContent = enabled ? 'ON' : 'OFF';
            }
            const btn = document.getElementById('motors-toggle');
            if (btn) {
                btn.classList.toggle('active', !!enabled);
            }
        }

        function toggleOverlayRecenter(button) {
            const checkbox = document.getElementById('camera-recenter-on-loss');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            button.classList.toggle('active', checkbox.checked);
            toggleRecenterOnLoss();
            setTimeout(() => {
                updateCameraTrackingStatus();
            }, 500);
        }

        function syncRecenterOverlayButton() {
            const checkbox = document.getElementById('camera-recenter-on-loss');
            const button = document.getElementById('recenter-toggle-btn');
            if (checkbox && button) {
                button.classList.toggle('active', checkbox.checked);
            }
        }

        function toggleLaserFromOverlay() {
            const checkbox = document.getElementById('laser-enabled');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            toggleLaser();
        }

        function toggleAutoFireFromOverlay() {
            const checkbox = document.getElementById('auto-fire-enabled');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            toggleAutoFire();
        }

        function toggleMockFireFromOverlay() {
            const checkbox = document.getElementById('mock-fire-enabled');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            toggleMockFire();
        }

        function toggleObjectDetectionFromOverlay() {
            const checkbox = document.getElementById('object-enabled');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            toggleObjectDetection();
        }

        function toggleObjectAutoTrackFromOverlay() {
            const checkbox = document.getElementById('object-auto-track-enabled');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            toggleObjectAutoTrack();
        }

        function syncLaserOverlay(status) {
            const systemEl = document.getElementById('overlay-laser-status');
            const readyEl = document.getElementById('overlay-laser-ready');
            const powerEl = document.getElementById('overlay-laser-power');
            const cooldownEl = document.getElementById('overlay-laser-cooldown');
            const enableBtn = document.getElementById('overlay-laser-enable');
            const autoBtn = document.getElementById('overlay-auto-fire');
            const mockBtn = document.getElementById('overlay-mock-fire');

            if (systemEl) systemEl.textContent = status.enabled ? 'ON' : 'OFF';
            const fireReady = status.ready_to_fire && status.enabled;
            if (readyEl) readyEl.textContent = fireReady ? 'Yes' : 'No';
            if (powerEl && status.power !== undefined) powerEl.textContent = `${status.power}%`;
            if (cooldownEl) {
                if (status.cooldown_remaining > 0) {
                    cooldownEl.textContent = `${status.cooldown_remaining.toFixed(1)}s`;
                } else {
                    cooldownEl.textContent = 'Ready';
                }
            }
            if (enableBtn) enableBtn.classList.toggle('active', !!status.enabled);
            if (autoBtn) autoBtn.classList.toggle('active', !!status.auto_fire);
            if (mockBtn) mockBtn.classList.toggle('active', !!status.mock_fire_mode);
        }

        function syncOverlayConfidenceFromMain() {
            const overlaySlider = document.getElementById('overlay-object-confidence');
            const overlayValue = document.getElementById('overlay-object-confidence-value');
            const hint = document.getElementById('overlay-object-hint');
            const methodEl = document.getElementById('detection-method');
            if (!overlaySlider || !overlayValue || !methodEl || !hint) return;

            const method = methodEl.value;
            if (method === 'haar') {
                overlaySlider.disabled = true;
                hint.style.display = 'block';
                overlayValue.textContent = '--';
                return;
            }

            hint.style.display = 'none';
            overlaySlider.disabled = false;

            let value = parseFloat(overlaySlider.value);
            if (method === 'tflite') {
                const slider = document.getElementById('tflite-confidence');
                if (slider) {
                    value = parseFloat(slider.value);
                }
            } else if (method === 'roboflow') {
                const slider = document.getElementById('roboflow-confidence');
                if (slider) {
                    value = parseFloat(slider.value);
                }
            }

            if (!Number.isNaN(value)) {
                overlaySlider.value = value;
                overlayValue.textContent = value.toFixed(2);
            }
        }

        function handleOverlayConfidenceInput(value) {
            const overlayValue = document.getElementById('overlay-object-confidence-value');
            const methodEl = document.getElementById('detection-method');
            if (overlayValue) {
                const num = parseFloat(value);
                if (!Number.isNaN(num)) {
                    overlayValue.textContent = num.toFixed(2);
                }
            }
            if (!methodEl) return;

            const method = methodEl.value;
            if (method === 'haar') {
                return;
            }

            if (method === 'tflite') {
                const slider = document.getElementById('tflite-confidence');
                if (slider) {
                    slider.value = value;
                    updateTFLiteConfidence();
                }
            } else if (method === 'roboflow') {
                const slider = document.getElementById('roboflow-confidence');
                if (slider) {
                    slider.value = value;
                    updateRoboflowConfidence();
                }
            }

            if (overlayConfidenceTimeout) {
                clearTimeout(overlayConfidenceTimeout);
            }
            overlayConfidenceTimeout = setTimeout(() => {
                if (method === 'tflite') {
                    applyTFLiteSettings();
                } else if (method === 'roboflow') {
                    applyRoboflowSettings();
                }
            }, 500);
        }

        function updateManualStepSize() {
            const value = document.getElementById('manual-step-size').value;
            document.getElementById('manual-step-size-value').textContent = `${value} px`;
        }

        function manualMove(axis, steps) {
            // Use the step size from slider instead of hardcoded value
            const stepSize = parseInt(document.getElementById('manual-step-size').value);
            const actualSteps = steps > 0 ? stepSize : -stepSize;
            
            fetch('/tracking/camera/manual_move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    axis: axis,
                    steps: actualSteps
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, data.message);
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to move camera');
                console.error('Error moving camera:', error);
            });
        }

        function setHomePosition() {
            if (!confirm('Set current position as home (0, 0)?')) return;
            
            fetch('/tracking/camera/set_home', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, data.message);
                    updateCameraTrackingStatus();
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to set home position');
                console.error('Error setting home position:', error);
            });
        }

        function runAutoCalibration() {
            if (!confirm('Run automatic calibration? This will move the camera through its full range of motion and may take several minutes. Ensure the area is clear.')) return;
            
            fetch('/tracking/camera/auto_calibrate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, data.message);
                    // Poll status more frequently during calibration
                    setTimeout(() => {
                        updateCameraTrackingStatus();
                    }, 5000);
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to start auto-calibration');
                console.error('Error starting auto-calibration:', error);
            });
        }

        function updateCalibrationUI(isCalibrated, timestamp) {
            // Update calibration status display
            if (isCalibrated) {
                document.getElementById('camera-calibration-status').textContent = 'Calibrated ‚úì';
                document.getElementById('camera-calibration-status').style.color = '#28a745';
                document.getElementById('calibration-required-warning').style.display = 'none';
                
                // Enable controls
                document.getElementById('camera-tracking-enabled').disabled = false;
                document.getElementById('home-camera-btn').disabled = false;
                
                // Enable manual control buttons
                document.querySelectorAll('[onclick^="manualMove"]').forEach(btn => {
                    btn.disabled = false;
                });
                document.querySelectorAll('[onclick="setHomePosition()"]').forEach(btn => {
                    btn.disabled = false;
                });
                document.querySelectorAll('[onclick="homeCameraPosition()"]').forEach(btn => {
                    btn.disabled = false;
                });
            } else {
                document.getElementById('camera-calibration-status').textContent = 'Not Calibrated';
                document.getElementById('camera-calibration-status').style.color = '#dc3545';
                document.getElementById('calibration-required-warning').style.display = 'block';
                
                // Disable controls
                document.getElementById('camera-tracking-enabled').disabled = true;
                document.getElementById('camera-tracking-enabled').checked = false;
                document.getElementById('home-camera-btn').disabled = true;
                
                // Disable manual control buttons
                document.querySelectorAll('[onclick^="manualMove"]').forEach(btn => {
                    btn.disabled = true;
                });
                document.querySelectorAll('[onclick="setHomePosition()"]').forEach(btn => {
                    btn.disabled = true;
                });
                document.querySelectorAll('[onclick="homeCameraPosition()"]').forEach(btn => {
                    btn.disabled = true;
                });
            }
        }

        function updateCameraTrackingStatus() {
            fetch('/tracking/camera/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Update tracking mode dropdown if needed
                        if (data.mode) {
                            document.getElementById('tracking-mode').value = data.mode;
                            updateTrackingModeUI(data.mode);
                        }
                        
                        if (data.available) {
                            document.getElementById('camera-system-status').textContent = 'Available';
                            document.getElementById('camera-enabled-status').textContent =
                                data.enabled ? 'Yes' : 'No';
                            syncMotorsToolbar(!!data.enabled);
                            // Sync re-center on loss toggle
                            const r = !!data.recenter_on_loss;
                            const rEl = document.getElementById('camera-recenter-on-loss');
                            if (rEl) rEl.checked = r;
                            syncRecenterOverlayButton();
                            
                            const controller = data.controller_status;
                            if (controller) {
                                document.getElementById('camera-position').textContent = 
                                    `${controller.position.x}, ${controller.position.y}`;
                                document.getElementById('camera-moving').textContent = 
                                    controller.moving ? 'Yes' : 'No';
                                
                                // Update crosshair position
                                updateCrosshairPosition();
                                
                                // Initialize calibration sliders ONLY on first load
                                // After that, preserve user's values until they save or refresh page
                                if (controller.calibration && !calibrationSlidersInitialized) {
                                    document.getElementById('camera-x-steps-per-pixel').value = 
                                        controller.calibration.x_steps_per_pixel;
                                    document.getElementById('camera-x-steps-value').textContent = 
                                        controller.calibration.x_steps_per_pixel.toFixed(2);
                                    
                                    document.getElementById('camera-y-steps-per-pixel').value = 
                                        controller.calibration.y_steps_per_pixel;
                                    document.getElementById('camera-y-steps-value').textContent = 
                                        controller.calibration.y_steps_per_pixel.toFixed(2);
                                    
                                    document.getElementById('camera-dead-zone').value = 
                                        controller.calibration.dead_zone_pixels;
                                    updateCameraDeadZoneValue();

                                    if (typeof controller.calibration.step_delay === 'number') {
                                        const sliderEl = document.getElementById('camera-step-delay');
                                        if (sliderEl) {
                                            let sliderVal = 0.0055 - controller.calibration.step_delay;
                                            sliderVal = Math.max(0.0005, Math.min(0.005, sliderVal));
                                            sliderEl.value = sliderVal;
                                            updateCameraStepDelayValue();
                                        }
                                    }
                                    
                                    // Mark as initialized so we don't overwrite user changes
                                    calibrationSlidersInitialized = true;
                                }
                                
                                // Update calibration status UI
                                if (controller.calibration) {
                                    updateCalibrationUI(
                                        controller.calibration.is_calibrated,
                                        controller.calibration.calibration_timestamp
                                    );
                                }
                                
                                // Sync PID sliders with controller values
                                fetch('/tracking/camera/pid')
                                    .then(r => r.json())
                                    .then(pd => {
                                        if (pd.status === 'success' && pd.pid) {
                                            const now = Date.now();
                                            const allowPIDSync = !pidEditing || (now - pidLastEditTs > EDIT_IDLE_MS);
                                            if (allowPIDSync) {
                                                const p = pd.pid;
                                                const kpEl = document.getElementById('pid-kp');
                                                const kiEl = document.getElementById('pid-ki');
                                                const kdEl = document.getElementById('pid-kd');
                                                const kpVal = document.getElementById('pid-kp-value');
                                                const kiVal = document.getElementById('pid-ki-value');
                                                const kdVal = document.getElementById('pid-kd-value');
                                                if (kpEl && kpVal) { kpEl.value = p.kp; kpVal.textContent = parseFloat(p.kp).toFixed(2); }
                                                if (kiEl && kiVal) { kiEl.value = p.ki; kiVal.textContent = parseFloat(p.ki).toFixed(2); }
                                                if (kdEl && kdVal) { kdEl.value = p.kd; kdVal.textContent = parseFloat(p.kd).toFixed(2); }
                                            }
                                        }
                                    })
                                    .catch(() => {});
                            }
                            
                            document.getElementById('camera-tracking-enabled').checked = data.enabled;
                        } else {
                            document.getElementById('camera-system-status').textContent = 'Not Available';
                            document.getElementById('camera-enabled-status').textContent = 'N/A';
                            syncMotorsToolbar(false);
                            syncRecenterOverlayButton();
                        }
                    }
                })
                .catch(error => console.error('Error fetching camera tracking status:', error));
        }

        // ============================================================
        // WebSocket Communication Setup
        // ============================================================
        
        // Connect to Socket.IO server
        const socket = io();
        
        // Handle connection events
        socket.on('connect', () => {
            console.log('‚úÖ WebSocket connected');
        });
        
        socket.on('disconnect', () => {
            console.warn('‚ùå WebSocket disconnected');
        });
        
        socket.on('connect_error', (error) => {
            console.error('WebSocket connection error:', error);
        });
        
        // Helper function to safely update DOM elements
        function safeUpdateElement(id, value) {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
            }
        }
        function setStatusDot(id, ok) {
            const el = document.getElementById(id);
            if (!el) return;
            el.classList.remove('status-ok', 'status-bad');
            el.classList.add(ok ? 'status-ok' : 'status-bad');
            el.setAttribute('title', ok ? 'Initialized' : 'Not initialized');
        }
        
        // Listen for consolidated status updates from server
        socket.on('status_update', (status) => {
            // Update FPS
            if (status.fps !== undefined) {
                safeUpdateElement('fps', `${status.fps} FPS`);
            }
            
            // Update exposure stats
            if (status.exposure) {
                safeUpdateElement('exp-time', `${(status.exposure.exposure_time/1000).toFixed(1)} ms`);
                safeUpdateElement('gain', `${status.exposure.analog_gain.toFixed(2)}x`);
                if (status.exposure.digital_gain !== undefined) {
                    safeUpdateElement('digital-gain', `${status.exposure.digital_gain.toFixed(2)}x`);
                }
            }
            
            // Update crosshair position
            if (status.crosshair) {
                const relX = status.crosshair.relative_x;
                const relY = status.crosshair.relative_y;
                safeUpdateElement('position', `(${relX >= 0 ? '+' : ''}${relX}, ${relY >= 0 ? '+' : ''}${relY})`);
                safeUpdateElement('crosshair-position', `${status.crosshair.absolute_x}, ${status.crosshair.absolute_y}`);
            }
            
            // Update crosshair calibration
            if (status.crosshair_calibration) {
                safeUpdateElement('crosshair-offset', `${status.crosshair_calibration.x}, ${status.crosshair_calibration.y}`);
            }
            
            // Update laser status
            if (status.laser) {
                syncLaserOverlay(status.laser);
                safeUpdateElement('laser-system-status', status.laser.enabled ? 'ON' : 'OFF');
                safeUpdateElement('laser-mock-mode', status.laser.mock_fire_mode ? 'ON (Visual Only)' : 'OFF');
                safeUpdateElement('laser-ready', status.laser.ready_to_fire ? 'Yes' : 'No');
                safeUpdateElement('laser-fire-count', status.laser.fire_count);
                
                // Update cooldown remaining
                if (status.laser.cooldown_remaining > 0) {
                    safeUpdateElement('laser-cooldown-remaining', status.laser.cooldown_remaining.toFixed(1) + 's');
                } else {
                    safeUpdateElement('laser-cooldown-remaining', 'Ready');
                }
                
                // Update power level and hardware status
                if (status.laser.power !== undefined) {
                    safeUpdateElement('laser-power-level', status.laser.power + '%');
                }
                safeUpdateElement('laser-hardware-status', status.laser.hardware_available ? 'Connected' : 'Simulation');
                
                // Update checkboxes
                const laserEnabledEl = document.getElementById('laser-enabled');
                if (laserEnabledEl) laserEnabledEl.checked = status.laser.enabled;
                
                const autoFireEl = document.getElementById('auto-fire-enabled');
                if (autoFireEl) autoFireEl.checked = status.laser.auto_fire;
                
                const mockFireEl = document.getElementById('mock-fire-enabled');
                if (mockFireEl) mockFireEl.checked = status.laser.mock_fire_mode || false;
                
                // NOTE: Laser sliders are NOT synced from WebSocket (like motion detection)
                // They are only updated on page load and when user clicks Apply
                // This prevents sliders from reverting while user is adjusting them
                
                // Update fire button state
                const fireReady = status.laser.ready_to_fire && status.laser.enabled;
                document.querySelectorAll('[data-fire-control]').forEach(btn => {
                    btn.disabled = !fireReady;
                });
            }
            
            // Update object detection status
            if (status.object_detection) {
                const objEnabled = status.object_detection.enabled;
                const objAutoTrack = status.object_detection.auto_track;
                const objCount = status.object_detection.count;
                const objMode = status.object_detection.mode;
                const objMethod = status.object_detection.method;

                safeUpdateElement('object-detection-status', objEnabled ? 'Enabled' : 'Disabled');
                safeUpdateElement('object-auto-track-status', objAutoTrack ? 'Yes' : 'No');
                safeUpdateElement('object-count', objCount);
                safeUpdateElement('object-detection-mode', objMode ? objMode.toUpperCase() : 'N/A');
                safeUpdateElement('detection-method-display', objMethod ? objMethod.toUpperCase() : 'N/A');

                const detectBtn = document.getElementById('overlay-objects-detect');
                if (detectBtn) detectBtn.classList.toggle('active', !!objEnabled);
                const trackBtn = document.getElementById('overlay-objects-track');
                if (trackBtn) trackBtn.classList.toggle('active', !!objAutoTrack);
                syncOverlayConfidenceFromMain();
            }
            
            // Update motion detection status
            if (status.motion_detection) {
                const motionEnabled = status.motion_detection.enabled;
                const motionAutoTrack = status.motion_detection.auto_track;
                const hasMotion = status.motion_detection.has_motion;
                
                safeUpdateElement('motion-detection-status', motionEnabled ? 'Enabled' : 'Disabled');
                safeUpdateElement('motion-auto-track-status', motionAutoTrack ? 'Yes' : 'No');
                safeUpdateElement('motion-detected', hasMotion ? 'Yes' : 'No');
            }
            
            // Update recording status
            if (status.recording) {
                safeUpdateElement('recording-status', status.recording.is_recording ? 'Recording' : 'Not Recording');
                if (status.recording.is_recording) {
                    const duration = Math.floor(status.recording.duration);
                    const mins = Math.floor(duration / 60);
                    const secs = duration % 60;
                    safeUpdateElement('recording-duration', `${mins}:${secs.toString().padStart(2, '0')}`);
                }
                if (status.recording.filename) {
                    safeUpdateElement('recording-filename', status.recording.filename);
                }
            }
            
            // Update pattern status
            if (status.pattern) {
                safeUpdateElement('pattern-status', status.pattern.running ? 'Running' : 'Stopped');
            }
            
            // Update tracking mode status
            if (status.tracking) {
                const modeToggle = document.getElementById('tracking-mode-toggle');
                if (modeToggle) {
                    modeToggle.checked = (status.tracking.mode === 'camera');
                }
                updateTrackingModeUI(status.tracking.mode);
            }
            
            // Update camera controller status (detailed)
            if (status.controller) {
                const ctrl = status.controller;
                
                safeUpdateElement('camera-system-status', 'Available');
                safeUpdateElement('camera-enabled-status', status.tracking.camera_enabled ? 'Yes' : 'No');
                
                // Update re-center on loss toggle
                const recenterEl = document.getElementById('camera-recenter-on-loss');
                if (recenterEl) {
                    recenterEl.checked = !!status.tracking.recenter_on_loss;
                }
                
                if (ctrl.position) {
                    safeUpdateElement('camera-position', `${ctrl.position.x}, ${ctrl.position.y}`);
                }
                
                safeUpdateElement('camera-moving', ctrl.moving ? 'Yes' : 'No');
                
                // Initialize calibration sliders ONLY on first load
                if (ctrl.calibration && !calibrationSlidersInitialized) {
                    const xStepsEl = document.getElementById('camera-x-steps-per-pixel');
                    const xStepsValEl = document.getElementById('camera-x-steps-value');
                    const yStepsEl = document.getElementById('camera-y-steps-per-pixel');
                    const yStepsValEl = document.getElementById('camera-y-steps-value');
                    const deadZoneEl = document.getElementById('camera-dead-zone');
                    const stepDelayEl = document.getElementById('camera-step-delay');
                    
                    if (xStepsEl && xStepsValEl) {
                        xStepsEl.value = ctrl.calibration.x_steps_per_pixel;
                        xStepsValEl.textContent = ctrl.calibration.x_steps_per_pixel.toFixed(2);
                    }
                    
                    if (yStepsEl && yStepsValEl) {
                        yStepsEl.value = ctrl.calibration.y_steps_per_pixel;
                        yStepsValEl.textContent = ctrl.calibration.y_steps_per_pixel.toFixed(2);
                    }
                    
                    if (deadZoneEl) {
                        deadZoneEl.value = ctrl.calibration.dead_zone_pixels;
                        updateCameraDeadZoneValue();
                    }
                    
                    if (stepDelayEl && typeof ctrl.calibration.step_delay === 'number') {
                        let sliderVal = 0.0055 - ctrl.calibration.step_delay;
                        sliderVal = Math.max(0.0005, Math.min(0.005, sliderVal));
                        stepDelayEl.value = sliderVal;
                        updateCameraStepDelayValue();
                    }
                    
                    calibrationSlidersInitialized = true;
                }
                
                // Update calibration status UI
                if (ctrl.calibration) {
                    updateCalibrationUI(
                        ctrl.calibration.is_calibrated,
                        ctrl.calibration.calibration_timestamp
                    );
                }
                
                // Sync PID sliders with controller values (with edit protection)
                if (ctrl.pid) {
                    const now = Date.now();
                    const allowPIDSync = !pidEditing || (now - pidLastEditTs > EDIT_IDLE_MS);
                    if (allowPIDSync) {
                        const kpEl = document.getElementById('pid-kp');
                        const kiEl = document.getElementById('pid-ki');
                        const kdEl = document.getElementById('pid-kd');
                        const kpVal = document.getElementById('pid-kp-value');
                        const kiVal = document.getElementById('pid-ki-value');
                        const kdVal = document.getElementById('pid-kd-value');
                        if (kpEl && kpVal) { kpEl.value = ctrl.pid.kp; kpVal.textContent = parseFloat(ctrl.pid.kp).toFixed(2); }
                        if (kiEl && kiVal) { kiEl.value = ctrl.pid.ki; kiVal.textContent = parseFloat(ctrl.pid.ki).toFixed(2); }
                        if (kdEl && kdVal) { kdEl.value = ctrl.pid.kd; kdVal.textContent = parseFloat(ctrl.pid.kd).toFixed(2); }
                    }
                }
                
                const camTrackEl = document.getElementById('camera-tracking-enabled');
                if (camTrackEl) {
                    camTrackEl.checked = status.tracking.camera_enabled;
                }
                syncMotorsToolbar(!!status.tracking.camera_enabled);
                syncRecenterOverlayButton();
                // Update motor init indicators
                if (ctrl.motors) {
                    if (ctrl.motors.x) setStatusDot('motor-x-dot', !!ctrl.motors.x.available);
                    if (ctrl.motors.y) setStatusDot('motor-y-dot', !!ctrl.motors.y.available);
                }
                // Update diagnostics (microsteps, idle, limit switches)
                if (typeof ctrl.microsteps === 'number') {
                    safeUpdateElement('controller-microsteps', String(ctrl.microsteps));
                }
                if (ctrl.idle) {
                    const sec = (typeof ctrl.idle.seconds_remaining === 'number') ? ctrl.idle.seconds_remaining : null;
                    if (sec !== null) {
                        const val = (sec > 0) ? sec.toFixed(1) + 's' : '0.0s';
                        safeUpdateElement('idle-seconds-remaining', val);
                    }
                    if (typeof ctrl.idle.active_moves === 'number') {
                        safeUpdateElement('idle-active-moves', String(ctrl.idle.active_moves));
                    }
                }
                if (ctrl.limit_switches && ctrl.limit_switches.pressed) {
                    const p = ctrl.limit_switches.pressed;
                    // green when NOT pressed, red when pressed
                    if (p.hasOwnProperty('x_cw')) setStatusDot('ls-x-cw', !p.x_cw);
                    if (p.hasOwnProperty('x_ccw')) setStatusDot('ls-x-ccw', !p.x_ccw);
                    if (p.hasOwnProperty('y_cw')) setStatusDot('ls-y-cw', !p.y_cw);
                    if (p.hasOwnProperty('y_ccw')) setStatusDot('ls-y-ccw', !p.y_ccw);
                }

            } else if (status.tracking && !status.tracking.camera_enabled) {
                safeUpdateElement('camera-system-status', 'Not Available');
                safeUpdateElement('camera-enabled-status', 'N/A');
                syncMotorsToolbar(false);
                syncRecenterOverlayButton();
            }
        });
        
        // ============================================================
        // Page Initialization
        // ============================================================
        
        async function initializeDetectionMethodFromConfig() {
            try {
                const resp = await fetch('/detection_method/config');
                const data = await resp.json();
                if (data && data.status === 'success' && data.method) {
                    // Ask backend to switch to configured method to ensure detectors are initialized
                    await fetch('/detection_method/switch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ method: data.method })
                    }).then(r => r.json()).catch(() => ({}));
                }
            } catch (e) {
                console.warn('Failed to initialize detection method from config:', e);
            }
        }

        (async () => {
            // Load presets on page load
            loadPresetList();

            // Sync sliders on page load (not from WebSocket)
            syncMotionSliders();
            syncLaserSliders();

            // Initialize camera step delay display
            updateCameraStepDelayValue();
            updateManualStepSize();
            syncOverlayConfidenceFromMain();
            syncRecenterOverlayButton();

            // Ensure backend detection method matches config before status pulls
            await initializeDetectionMethodFromConfig();

            updateLaserStatus();
            updateObjectStatus();
            updateCameraTrackingStatus();
        })();

        console.log('üöÄ Laser Turret Control Panel initialized with WebSocket support');
    </script>
</body>
</html>

