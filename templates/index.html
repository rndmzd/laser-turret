<!DOCTYPE html>
<html>
<head>
    <title>Laser Turret Control Panel</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/app.css') }}">
    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¯ Laser Turret Control Panel</h1>
            <p>Advanced Camera Control & Monitoring System</p>
        </div>

        <div class="control-layout">
            <section class="video-section">
                <div class="video-wrapper">
                    <img id="video-stream" src="{{ url_for('video_feed') }}" alt="Video stream">

                    <div class="overlay-toolbar">
                        <button id="motors-toggle" class="toolbar-button" onclick="toggleMotorsFromToolbar(this)">
                            Motors
                            <span class="state-pill" id="motors-state">--</span>
                        </button>
                        <button class="toolbar-button active" data-overlay-target="movement" onclick="toggleOverlayPanel('movement-overlay', this)">Movement</button>
                        <button class="toolbar-button" data-overlay-target="objects" onclick="toggleOverlayPanel('objects-overlay', this)">Objects</button>
                        <button class="toolbar-button" data-overlay-target="laser" onclick="toggleOverlayPanel('laser-overlay', this)">Laser</button>
                    </div>

                    <div class="overlay-panel floating-controls movement-overlay active" id="movement-overlay" data-overlay-key="movement">
                        <div class="direction-pad">
                            <span class="spacer"></span>
                            <button class="pad-button" onclick="manualMove('y', -1)" aria-label="Nudge up" title="Nudge up">â–²</button>
                            <span class="spacer"></span>
                            <button class="pad-button" onclick="manualMove('x', -1)" aria-label="Nudge left" title="Nudge left">â—„</button>
                            <button class="pad-button fire-button" data-fire-control onclick="fireLaser(this)" aria-label="Fire laser" title="Fire laser">
                                <span>Fire</span>
                            </button>
        </aside>
    </div>
</div>

    <script>
        const CAMERA_WIDTH = 1920;
        const CAMERA_HEIGHT = 1080;
        let crosshairCalibrationMode = false;

        // Editing guards to avoid UI snapping back during WebSocket updates
        const EDIT_IDLE_MS = 1500;
        let tfliteEditing = false;
        let tfliteLastEditTs = 0;
        let roboflowEditing = false;
        let roboflowLastEditTs = 0;
        let balloonEditing = false;
        let balloonLastEditTs = 0;
        let pidEditing = false;
        let pidLastEditTs = 0;

        // Tab switching
        function switchTab(tabName, buttonEl) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            const targetContent = document.getElementById(`${tabName}-tab`);
            if (targetContent) {
                targetContent.classList.add('active');
            }

            const targetButton = buttonEl || document.querySelector(`.tab[data-tab="${tabName}"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }

            // If leaving Object tab, make sure method-specific panels are hidden
            if (tabName !== 'object') {
                ['haar-settings','tflite-settings','roboflow-settings','current-mode-row','tflite-stats','roboflow-stats']
                    .forEach(id => { const el = document.getElementById(id); if (el) el.style.display = 'none'; });
            } else {
                // Refresh object status to show appropriate panel for selected method
                updateObjectStatus();
            }
        }

        // Crosshair positioning with camera movement support
        document.getElementById('video-stream').addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const scaleX = CAMERA_WIDTH / this.offsetWidth;
            const scaleY = CAMERA_HEIGHT / this.offsetHeight;
            const clickX = (e.clientX - rect.left);
            const clickY = (e.clientY - rect.top);
            const cameraX = Math.round(clickX * scaleX);
            const cameraY = Math.round(clickY * scaleY);
            
            if (crosshairCalibrationMode) {
                fetch('/crosshair/calibration/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: cameraX, y: cameraY })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('position').textContent = `X: ${data.absolute.x}, Y: ${data.absolute.y}`;
                        const off = data.offset;
                        document.getElementById('crosshair-offset').textContent = `${off.x}, ${off.y}`;
                        showStatus('crosshair-calibration-status', true, 'Calibration updated');
                    } else {
                        showStatus('crosshair-calibration-status', false, data.message || 'Failed to set calibration');
                    }
                })
                .catch(error => {
                    console.error('Error setting calibration:', error);
                    showStatus('crosshair-calibration-status', false, 'Failed to set calibration');
                });
                return;
            }

            // Check if camera tracking is enabled and active
            const trackingMode = document.getElementById('tracking-mode').value;
            const cameraTrackingEnabled = document.getElementById('camera-tracking-enabled').checked;
            
            if (trackingMode === 'camera' && cameraTrackingEnabled) {
                // Camera movement mode: move camera to recenter clicked position
                // Crosshair stays centered, don't update position display
                fetch('/tracking/camera/move_to_position', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: cameraX, y: cameraY })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Visual feedback
                        showStatus('tracking-status-message', true, 'Camera moving to recenter position...');
                    } else {
                        showStatus('tracking-status-message', false, data.message);
                    }
                })
                .catch(error => {
                    console.error('Error moving camera to position:', error);
                    showStatus('tracking-status-message', false, 'Failed to move camera');
                });
            } else {
                // Crosshair mode: update crosshair position
                document.getElementById('position').textContent = `X: ${cameraX}, Y: ${cameraY}`;
                fetch('/update_crosshair', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: cameraX, y: cameraY })
                });
            }
        });

        // Reset crosshair to center
        function resetCrosshair() {
            fetch('/reset_crosshair', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    document.getElementById('position').textContent = `X: ${data.x}, Y: ${data.y}`;
                }
            })
            .catch(error => console.error('Error resetting crosshair:', error));
        }

        function toggleCrosshairCalibration() {
            const enabled = document.getElementById('crosshair-calibration-enabled').checked;
            crosshairCalibrationMode = enabled;
            showStatus('crosshair-calibration-status', true, enabled ? 'Calibration mode ON. Click video to set default crosshair.' : 'Calibration mode OFF');
        }

        function resetCrosshairCalibration() {
            fetch('/crosshair/calibration/reset', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const off = data.offset || {x:0,y:0};
                    document.getElementById('crosshair-offset').textContent = `${off.x}, ${off.y}`;
                    document.getElementById('position').textContent = `X: ${data.absolute.x}, Y: ${data.absolute.y}`;
                    showStatus('crosshair-calibration-status', true, 'Calibration reset');
                } else {
                    showStatus('crosshair-calibration-status', false, data.message || 'Failed to reset calibration');
                }
            })
            .catch(error => {
                console.error('Error resetting calibration:', error);
                showStatus('crosshair-calibration-status', false, 'Failed to reset calibration');
            });
        }

        function updateCrosshairCalibration() {
            fetch('/crosshair/calibration')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.offset) {
                        document.getElementById('crosshair-offset').textContent = `${data.offset.x}, ${data.offset.y}`;
                    }
                })
                .catch(error => console.error('Error fetching crosshair calibration:', error));
        }

        // Exposure controls
        function toggleAutoExposure() {
            const autoEnabled = document.getElementById('auto-exposure').checked;
            document.getElementById('manual-exposure-controls').style.display = autoEnabled ? 'none' : 'block';
            fetch('/set_exposure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ auto: autoEnabled })
            })
            .then(response => response.json())
            .then(data => showStatus('exposure-status', data.status === 'success', 
                autoEnabled ? 'Auto exposure enabled' : 'Manual exposure mode'));
        }

        function updateExposureValue() {
            const value = document.getElementById('exposure-time').value;
            document.getElementById('exposure-time-value').textContent = value;
        }

        function updateAnalogGainValue() {
            const value = parseFloat(document.getElementById('analog-gain').value).toFixed(1);
            document.getElementById('analog-gain-value').textContent = value;
        }

        function updateDigitalGainValue() {
            const value = parseFloat(document.getElementById('digital-gain').value).toFixed(1);
            document.getElementById('digital-gain-value').textContent = value;
        }

        function applyExposure() {
            const exposureTime = parseInt(document.getElementById('exposure-time').value);
            const analogGain = parseFloat(document.getElementById('analog-gain').value);
            const digitalGain = parseFloat(document.getElementById('digital-gain').value);
            fetch('/set_exposure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    auto: false,
                    exposure_time: exposureTime,
                    analog_gain: analogGain,
                    digital_gain: digitalGain
                })
            })
            .then(response => response.json())
            .then(data => showStatus('exposure-status', data.status === 'success', 
                data.status === 'success' ? 'Exposure settings applied' : data.message));
        }

        // White balance controls
        function toggleAutoWB() {
            const autoEnabled = document.getElementById('auto-wb').checked;
            document.getElementById('wb-mode-control').style.display = autoEnabled ? 'none' : 'block';
            fetch('/set_white_balance', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ auto: autoEnabled })
            })
            .then(response => response.json())
            .then(data => showStatus('exposure-status', data.status === 'success',
                autoEnabled ? 'Auto white balance enabled' : 'Manual white balance mode'));
        }

        function applyWhiteBalance() {
            const mode = parseInt(document.getElementById('wb-mode').value);
            fetch('/set_white_balance', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ auto: false, mode: mode })
            })
            .then(response => response.json())
            .then(data => showStatus('exposure-status', data.status === 'success',
                data.status === 'success' ? 'White balance applied' : data.message));
        }

        // Image adjustment controls
        function updateBrightnessValue() {
            const value = parseFloat(document.getElementById('brightness').value).toFixed(1);
            document.getElementById('brightness-value').textContent = value;
        }

        function updateContrastValue() {
            const value = parseFloat(document.getElementById('contrast').value).toFixed(1);
            document.getElementById('contrast-value').textContent = value;
        }

        function updateSaturationValue() {
            const value = parseFloat(document.getElementById('saturation').value).toFixed(1);
            document.getElementById('saturation-value').textContent = value;
        }

        function applyImageParams() {
            const brightness = parseFloat(document.getElementById('brightness').value);
            const contrast = parseFloat(document.getElementById('contrast').value);
            const saturation = parseFloat(document.getElementById('saturation').value);
            fetch('/set_image_params', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    brightness: brightness,
                    contrast: contrast,
                    saturation: saturation
                })
            })
            .then(response => response.json())
            .then(data => showStatus('image-status', data.status === 'success',
                data.status === 'success' ? 'Image settings applied' : data.message));
        }

        function resetImageParams() {
            document.getElementById('brightness').value = 0;
            document.getElementById('contrast').value = 1;
            document.getElementById('saturation').value = 1;
            updateBrightnessValue();
            updateContrastValue();
            updateSaturationValue();
            applyImageParams();
        }

        // Image capture
        function captureImage() {
            fetch('/capture_image', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => showStatus('capture-status', data.status === 'success',
                data.status === 'success' ? `Image saved: ${data.filename}` : data.message));
        }

        // Status message display
        function showStatus(elementId, success, message) {
            const statusEl = document.getElementById(elementId);
            statusEl.className = 'status-message ' + (success ? 'status-success' : 'status-error');
            statusEl.textContent = message;
            statusEl.style.display = 'block';
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }

        // Video recording controls
        function startRecording() {
            fetch('/start_recording', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    document.getElementById('start-recording-btn').style.display = 'none';
                    document.getElementById('stop-recording-btn').style.display = 'block';
                    document.getElementById('recording-info').style.display = 'block';
                    document.getElementById('recording-filename').textContent = data.filename;
                    showStatus('recording-status', true, 'Recording started');
                } else {
                    showStatus('recording-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('recording-status', false, 'Failed to start recording');
                console.error('Error starting recording:', error);
            });
        }

        function stopRecording() {
            fetch('/stop_recording', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    document.getElementById('start-recording-btn').style.display = 'block';
                    document.getElementById('stop-recording-btn').style.display = 'none';
                    document.getElementById('recording-info').style.display = 'none';
                    const duration = data.duration ? `${Math.floor(data.duration)}s` : '';
                    showStatus('recording-status', true, 
                        `Recording saved: ${data.filename} (${duration})`);
                } else {
                    showStatus('recording-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('recording-status', false, 'Failed to stop recording');
                console.error('Error stopping recording:', error);
            });
        }

        function updateRecordingStatus() {
            fetch('/recording_status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.is_recording) {
                        // Update duration display
                        const duration = Math.floor(data.duration);
                        const minutes = Math.floor(duration / 60);
                        const seconds = duration % 60;
                        document.getElementById('recording-duration').textContent = 
                            `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        
                        // Ensure UI is in recording state
                        document.getElementById('start-recording-btn').style.display = 'none';
                        document.getElementById('stop-recording-btn').style.display = 'block';
                        document.getElementById('recording-info').style.display = 'block';
                        document.getElementById('recording-filename').textContent = data.filename;
                    }
                })
                .catch(error => console.error('Error checking recording status:', error));
        }

        // Laser control functions
        function toggleLaser() {
            const enabled = document.getElementById('laser-enabled').checked;
            fetch('/laser/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, 
                        enabled ? 'Laser system enabled' : 'Laser system disabled');
                    updateLaserStatus();
                } else {
                    showStatus('laser-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to toggle laser');
                console.error('Error toggling laser:', error);
            });
        }

        function toggleAutoFire() {
            const enabled = document.getElementById('auto-fire-enabled').checked;
            fetch('/laser/auto_fire', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, 
                        enabled ? 'Auto-fire enabled' : 'Auto-fire disabled');
                } else {
                    showStatus('laser-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to toggle auto-fire');
                console.error('Error toggling auto-fire:', error);
            });
        }

        function fireLaser(triggerButton) {
            const fireButtons = Array.from(document.querySelectorAll('[data-fire-control]'));

            if (triggerButton instanceof HTMLElement && !fireButtons.includes(triggerButton)) {
                fireButtons.push(triggerButton);
            }

            fireButtons.forEach(btn => btn.disabled = true);

            fetch('/laser/fire', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, data.message);
                    updateLaserStatus();
                } else {
                    showStatus('laser-status-message', false, data.message);
                    fireButtons.forEach(btn => btn.disabled = false);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to fire laser');
                console.error('Error firing laser:', error);
                fireButtons.forEach(btn => btn.disabled = false);
            });
        }

        function updatePulseDurationValue() {
            const value = document.getElementById('pulse-duration').value;
            document.getElementById('pulse-duration-value').textContent = value + 'ms';
        }

        function updateBurstCountValue() {
            const value = document.getElementById('burst-count').value;
            document.getElementById('burst-count-value').textContent = value;
        }

        function updateBurstDelayValue() {
            const value = document.getElementById('burst-delay').value;
            document.getElementById('burst-delay-value').textContent = value + 'ms';
        }

        function updateLaserCooldownValue() {
            const value = parseFloat(document.getElementById('laser-cooldown').value).toFixed(1);
            document.getElementById('laser-cooldown-value').textContent = value + 's';
        }

        function updateLaserPowerValue() {
            const value = parseInt(document.getElementById('laser-power').value);
            document.getElementById('laser-power-value').textContent = value + '%';
        }

        function applyLaserSettings() {
            const pulseDuration = parseFloat(document.getElementById('pulse-duration').value) / 1000;
            const burstCount = parseInt(document.getElementById('burst-count').value);
            const burstDelay = parseFloat(document.getElementById('burst-delay').value) / 1000;
            const cooldown = parseFloat(document.getElementById('laser-cooldown').value);
            const power = parseInt(document.getElementById('laser-power').value);
            
            fetch('/laser/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    pulse_duration: pulseDuration,
                    burst_count: burstCount,
                    burst_delay: burstDelay,
                    cooldown: cooldown,
                    power: power
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, `Laser settings applied (Power: ${data.power}%)`);
                } else {
                    showStatus('laser-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to apply laser settings');
                console.error('Error applying laser settings:', error);
            });
        }

        function updateLaserStatus() {
            fetch('/laser/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('laser-system-status').textContent =
                            data.enabled ? 'ON' : 'OFF';
                        document.getElementById('laser-ready').textContent =
                            data.ready_to_fire ? 'Yes' : 'No';
                        document.getElementById('laser-fire-count').textContent = 
                            data.fire_count;
                        
                        if (data.cooldown_remaining > 0) {
                            document.getElementById('laser-cooldown-remaining').textContent = 
                                data.cooldown_remaining.toFixed(1) + 's';
                        } else {
                            document.getElementById('laser-cooldown-remaining').textContent = 'Ready';
                        }
                        
                        // Display power level and hardware status
                        if (data.power !== undefined) {
                            document.getElementById('laser-power-level').textContent = data.power + '%';
                        }
                        document.getElementById('laser-hardware-status').textContent = 
                            data.hardware_available ? 'Connected' : 'Simulation';
                        
                        document.getElementById('laser-enabled').checked = data.enabled;
                        document.getElementById('auto-fire-enabled').checked = data.auto_fire;

                        // NOTE: Sliders are NOT synced from status updates (matches motion detection pattern)
                        // They are only synced on page load via syncLaserSliders()

                        const fireReady = data.ready_to_fire && data.enabled;
                        document.querySelectorAll('[data-fire-control]').forEach(btn => {
                            btn.disabled = !fireReady;
                        });

                        syncLaserOverlay(data);
                    }
                })
                .catch(error => console.error('Error fetching laser status:', error));
        }

        function resetFireCount() {
            if (!confirm('Reset fire counter to 0?')) return;
            
            fetch('/laser/reset_count', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('laser-status-message', true, 'Fire counter reset');
                    updateLaserStatus();
                } else {
                    showStatus('laser-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('laser-status-message', false, 'Failed to reset counter');
                console.error('Error resetting counter:', error);
            });
        }

        // Preset position controls
        function savePreset() {
            const slot = parseInt(document.getElementById('save-slot').value);
            const label = document.getElementById('preset-label').value || `Preset ${slot}`;
            
            fetch('/presets/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ slot: slot, label: label })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, `Saved to slot ${slot}`);
                    document.getElementById('preset-label').value = '';
                    loadPresetList();
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to save preset');
                console.error('Error saving preset:', error);
            });
        }

        function loadPreset(slot) {
            fetch(`/presets/load/${slot}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, `Loaded ${data.label}`);
                    document.getElementById('position').textContent = `X: ${data.position.x}, Y: ${data.position.y}`;
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to load preset');
                console.error('Error loading preset:', error);
            });
        }

        function deletePreset(slot) {
            if (!confirm(`Delete preset ${slot}?`)) return;
            
            fetch(`/presets/delete/${slot}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, `Deleted slot ${slot}`);
                    loadPresetList();
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to delete preset');
                console.error('Error deleting preset:', error);
            });
        }

        function loadPresetList() {
            fetch('/presets/list')
                .then(response => response.json())
                .then(data => {
                    const listEl = document.getElementById('preset-list');
                    const presets = data.presets;
                    
                    if (Object.keys(presets).length === 0) {
                        listEl.innerHTML = '<p class="empty-state">No presets saved</p>';
                        return;
                    }
                    
                    let html = '';
                    for (const [slot, preset] of Object.entries(presets).sort((a, b) => a[0] - b[0])) {
                        html += `
                            <div class="preset-item">
                                <div class="preset-info">
                                    <div><span class="preset-slot">#${slot}</span> <span class="preset-label">${preset.label}</span></div>
                                    <div class="preset-coords">X: ${preset.x}, Y: ${preset.y}</div>
                                </div>
                                <div class="preset-actions">
                                    <button class="preset-btn preset-btn-load" onclick="loadPreset(${slot})">Load</button>
                                    <button class="preset-btn preset-btn-delete" onclick="deletePreset(${slot})">Delete</button>
                                </div>
                            </div>
                        `;
                    }
                    listEl.innerHTML = html;
                })
                .catch(error => console.error('Error loading preset list:', error));
        }

        function updatePatternDelayValue() {
            const value = parseFloat(document.getElementById('pattern-delay').value).toFixed(1);
            document.getElementById('pattern-delay-value').textContent = value + 's';
        }

        function startPattern() {
            const sequenceStr = document.getElementById('pattern-sequence').value;
            const delay = parseFloat(document.getElementById('pattern-delay').value);
            const loop = document.getElementById('pattern-loop').checked;
            
            // Parse sequence
            const sequence = sequenceStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
            
            if (sequence.length === 0) {
                showStatus('preset-status', false, 'Enter a valid sequence');
                return;
            }
            
            fetch('/presets/pattern/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sequence: sequence, delay: delay, loop: loop })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, 'Pattern started');
                    document.getElementById('start-pattern-btn').style.display = 'none';
                    document.getElementById('stop-pattern-btn').style.display = 'block';
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to start pattern');
                console.error('Error starting pattern:', error);
            });
        }

        function stopPattern() {
            fetch('/presets/pattern/stop', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('preset-status', true, 'Pattern stopped');
                    document.getElementById('start-pattern-btn').style.display = 'block';
                    document.getElementById('stop-pattern-btn').style.display = 'none';
                } else {
                    showStatus('preset-status', false, data.message);
                }
            })
            .catch(error => {
                showStatus('preset-status', false, 'Failed to stop pattern');
                console.error('Error stopping pattern:', error);
            });
        }

        function updatePatternStatus() {
            fetch('/presets/pattern/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.running) {
                        document.getElementById('start-pattern-btn').style.display = 'none';
                        document.getElementById('stop-pattern-btn').style.display = 'block';
                    } else {
                        document.getElementById('start-pattern-btn').style.display = 'block';
                        document.getElementById('stop-pattern-btn').style.display = 'none';
                    }
                })
                .catch(error => console.error('Error checking pattern status:', error));
        }

        // Keyboard shortcuts for presets (1-9, 0 for slot 10)
        document.addEventListener('keydown', function(e) {
            // Only trigger if not typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const key = e.key;
            if (key >= '1' && key <= '9') {
                const slot = parseInt(key);
                loadPreset(slot);
                e.preventDefault();
            } else if (key === '0') {
                loadPreset(10);
                e.preventDefault();
            }
        });

        // Object detection controls
        function toggleObjectDetection() {
            const enabled = document.getElementById('object-enabled').checked;
            fetch('/object_detection/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 
                        enabled ? 'Object detection enabled' : 'Object detection disabled');
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to toggle object detection');
                console.error('Error toggling object detection:', error);
            });
        }

        function toggleObjectAutoTrack() {
            const enabled = document.getElementById('object-auto-track-enabled').checked;
            fetch('/object_detection/auto_track', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true,
                        enabled ? 'Object auto-tracking enabled' : 'Object auto-tracking disabled');
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to toggle object auto-track');
                console.error('Error toggling object auto-track:', error);
            });
        }

        function applyObjectSettings() {
            const mode = document.getElementById('detection-mode').value;
            const priority = document.getElementById('target-priority').value;
            // Update balloon settings visibility immediately
            showHideBalloonSettings();
            
            fetch('/object_detection/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    mode: mode,
                    priority: priority
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 'Object detection settings applied');
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to apply object settings');
                console.error('Error applying object settings:', error);
            });
        }

        function switchDetectionMethod() {
            const method = document.getElementById('detection-method').value;
            
            // Show/hide method-specific settings
            const haarSettings = document.getElementById('haar-settings');
            const tfliteSettings = document.getElementById('tflite-settings');
            const roboflowSettings = document.getElementById('roboflow-settings');
            const currentModeRow = document.getElementById('current-mode-row');
            const tfliteStats = document.getElementById('tflite-stats');
            const roboflowStats = document.getElementById('roboflow-stats');
            const balloonSettings = document.getElementById('balloon-settings');
            
            // Hide all first
            haarSettings.style.display = 'none';
            tfliteSettings.style.display = 'none';
            roboflowSettings.style.display = 'none';
            tfliteStats.style.display = 'none';
            roboflowStats.style.display = 'none';
            if (balloonSettings) balloonSettings.style.display = 'none';
            
            if (method === 'haar') {
                haarSettings.style.display = 'block';
                currentModeRow.style.display = 'flex';
                document.getElementById('detection-method-display').textContent = 'Haar Cascades';
                showHideBalloonSettings();
            } else if (method === 'tflite') {
                tfliteSettings.style.display = 'block';
                currentModeRow.style.display = 'none';
                tfliteStats.style.display = 'block';
                document.getElementById('detection-method-display').textContent = 'TensorFlow Lite';
            } else if (method === 'roboflow') {
                roboflowSettings.style.display = 'block';
                currentModeRow.style.display = 'none';
                roboflowStats.style.display = 'block';
                document.getElementById('detection-method-display').textContent = 'Roboflow Inference';
            }
            
            syncOverlayConfidenceFromMain();

            // Switch method on server
            fetch('/detection_method/switch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ method: method })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const methodNames = {
                        'haar': 'Haar Cascades',
                        'tflite': 'TensorFlow Lite',
                        'roboflow': 'Roboflow Inference'
                    };
                    showStatus('object-status-message', true, 
                        `Switched to ${methodNames[method] || method}`);
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                    // Revert on failure
                    document.getElementById('detection-method').value = 
                        data.detection_method || 'haar';
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to switch detection method');
                console.error('Error switching detection method:', error);
            });
        }

        function updateTFLiteConfidence() {
            const value = document.getElementById('tflite-confidence').value;
            document.getElementById('tflite-confidence-value').textContent = value;
            tfliteLastEditTs = Date.now();
            tfliteEditing = true;
        }

        function applyTFLiteSettings() {
            const confidence = parseFloat(document.getElementById('tflite-confidence').value);
            const filterClasses = document.getElementById('tflite-filter-classes').value;
            
            fetch('/tflite/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    confidence: confidence,
                    filter_classes: filterClasses
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 
                        `TFLite settings applied - Confidence: ${data.confidence.toFixed(2)}`);
                    tfliteEditing = false;
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to apply TFLite settings');
                console.error('Error applying TFLite settings:', error);
            });
        }

        function updateRoboflowConfidence() {
            const value = document.getElementById('roboflow-confidence').value;
            document.getElementById('roboflow-confidence-value').textContent = value;
            roboflowLastEditTs = Date.now();
            roboflowEditing = true;
        }

        function applyRoboflowSettings() {
            const serverUrl = document.getElementById('roboflow-server-url').value;
            const modelId = document.getElementById('roboflow-model-id').value;
            const apiKey = document.getElementById('roboflow-api-key').value;
            const confidence = parseFloat(document.getElementById('roboflow-confidence').value);
            const filterClasses = document.getElementById('roboflow-filter-classes').value;
            
            fetch('/roboflow/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    server_url: serverUrl || undefined,
                    model_id: modelId || undefined,
                    api_key: apiKey || undefined,
                    confidence: confidence,
                    filter_classes: filterClasses
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 
                        `Roboflow settings applied - Confidence: ${data.confidence ? data.confidence.toFixed(2) : 'N/A'}`);
                    roboflowEditing = false;
                    // Switch to Roboflow method after applying settings
                    fetch('/detection_method/switch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ method: 'roboflow' })
                    })
                    .then(r => r.json())
                    .then(sw => {
                        if (sw.status === 'success') {
                            document.getElementById('detection-method').value = 'roboflow';
                            updateObjectStatus();
                        } else {
                            showStatus('object-status-message', false, sw.message || 'Failed to switch to Roboflow');
                        }
                    })
                    .catch(err => {
                        console.error('Error switching to Roboflow:', err);
                    });
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to apply Roboflow settings');
                console.error('Error applying Roboflow settings:', error);
            });
        }

        function updateObjectStatus() {
            fetch('/object_detection/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('object-status').textContent = 
                            data.enabled ? 'ON' : 'OFF';
                        document.getElementById('objects-count').textContent = 
                            data.objects_detected;
                        
                        // Update detection method
                        const method = data.detection_method || 'haar';
                        document.getElementById('detection-method').value = method;
                        
                        // Show/hide appropriate settings
                        const haarSettings = document.getElementById('haar-settings');
                        const tfliteSettings = document.getElementById('tflite-settings');
                        const roboflowSettings = document.getElementById('roboflow-settings');
                        const currentModeRow = document.getElementById('current-mode-row');
                        const tfliteStats = document.getElementById('tflite-stats');
                        const roboflowStats = document.getElementById('roboflow-stats');
                        const balloonSettings = document.getElementById('balloon-settings');
                        
                        // Hide all first
                        haarSettings.style.display = 'none';
                        tfliteSettings.style.display = 'none';
                        roboflowSettings.style.display = 'none';
                        tfliteStats.style.display = 'none';
                        roboflowStats.style.display = 'none';
                        if (balloonSettings) balloonSettings.style.display = 'none';
                        
                        if (method === 'haar') {
                            haarSettings.style.display = 'block';
                            currentModeRow.style.display = 'flex';
                            document.getElementById('detection-method-display').textContent = 'Haar Cascades';
                            document.getElementById('current-mode').textContent = 
                                data.mode.charAt(0).toUpperCase() + data.mode.slice(1);
                            document.getElementById('detection-mode').value = data.mode;
                            // Sync balloon sliders from status
                            const bs = data.balloon_settings || {};
                            if (document.getElementById('balloon-v-threshold')) {
                                const now = Date.now();
                                const allowBalloonSync = !balloonEditing || (now - balloonLastEditTs > EDIT_IDLE_MS);
                                if (allowBalloonSync) {
                                    document.getElementById('balloon-v-threshold').value = bs.v_threshold ?? 60;
                                    document.getElementById('balloon-v-value').textContent = bs.v_threshold ?? 60;
                                    document.getElementById('balloon-min-area').value = bs.min_area ?? 2000;
                                    document.getElementById('balloon-min-area-value').textContent = bs.min_area ?? 2000;
                                    document.getElementById('balloon-circularity').value = bs.circularity_min ?? 0.55;
                                    document.getElementById('balloon-circularity-value').textContent = (bs.circularity_min ?? 0.55).toFixed(2);
                                    document.getElementById('balloon-fill').value = bs.fill_ratio_min ?? 0.5;
                                    document.getElementById('balloon-fill-value').textContent = (bs.fill_ratio_min ?? 0.5).toFixed(2);
                                    document.getElementById('balloon-ar-min').value = bs.aspect_ratio_min ?? 0.6;
                                    document.getElementById('balloon-ar-min-value').textContent = (bs.aspect_ratio_min ?? 0.6).toFixed(2);
                                    document.getElementById('balloon-ar-max').value = bs.aspect_ratio_max ?? 1.6;
                                    document.getElementById('balloon-ar-max-value').textContent = (bs.aspect_ratio_max ?? 1.6).toFixed(2);
                                    showHideBalloonSettings();
                                }
                            }
                        } else if (method === 'tflite') {
                            tfliteSettings.style.display = 'block';
                            currentModeRow.style.display = 'none';
                            tfliteStats.style.display = 'block';
                            document.getElementById('detection-method-display').textContent = 'TensorFlow Lite';
                            
                            // Update TFLite stats if available
                            if (data.tflite_stats) {
                                const stats = data.tflite_stats;
                                document.getElementById('tflite-inference-time').textContent = 
                                    stats.avg_inference_ms.toFixed(1) + ' ms';
                                document.getElementById('tflite-fps').textContent = 
                                    stats.estimated_fps.toFixed(1) + ' FPS';
                                document.getElementById('tflite-accelerator').textContent = 
                                    stats.accelerator;
                                
                                if (stats.confidence_threshold !== undefined) {
                                    const now = Date.now();
                                    const allowTFLiteSync = !tfliteEditing || (now - tfliteLastEditTs > EDIT_IDLE_MS);
                                    if (allowTFLiteSync) {
                                        document.getElementById('tflite-confidence').value = stats.confidence_threshold;
                                        document.getElementById('tflite-confidence-value').textContent = 
                                            stats.confidence_threshold.toFixed(2);
                                    }
                                }
                            }
                        } else if (method === 'roboflow') {
                            roboflowSettings.style.display = 'block';
                            currentModeRow.style.display = 'none';
                            roboflowStats.style.display = 'block';
                            document.getElementById('detection-method-display').textContent = 'Roboflow Inference';
                            
                            // Update Roboflow stats if available
                            if (data.roboflow_stats) {
                                const stats = data.roboflow_stats;
                                document.getElementById('roboflow-server-display').textContent = 
                                    stats.server_url || '--';
                                document.getElementById('roboflow-model-display').textContent = 
                                    stats.model_id || '--';
                                document.getElementById('roboflow-inference-time').textContent = 
                                    stats.avg_inference_ms ? stats.avg_inference_ms.toFixed(1) + ' ms' : '--';
                                document.getElementById('roboflow-fps').textContent = 
                                    stats.estimated_fps ? stats.estimated_fps.toFixed(1) + ' FPS' : '--';
                                
                                const now = Date.now();
                                const allowRoboflowSync = !roboflowEditing || (now - roboflowLastEditTs > EDIT_IDLE_MS);
                                if (allowRoboflowSync) {
                                    // Populate form fields with current settings
                                    if (stats.server_url) {
                                        document.getElementById('roboflow-server-url').value = stats.server_url;
                                    }
                                    if (stats.model_id) {
                                        document.getElementById('roboflow-model-id').value = stats.model_id;
                                    }
                                    if (stats.confidence !== undefined) {
                                        document.getElementById('roboflow-confidence').value = stats.confidence;
                                        document.getElementById('roboflow-confidence-value').textContent = 
                                            stats.confidence.toFixed(2);
                                    }
                                    if (stats.class_filter && stats.class_filter.length > 0) {
                                        document.getElementById('roboflow-filter-classes').value = 
                                            stats.class_filter.join(',');
                                    }
                                }
                                // Reflect API key presence without exposing it
                                const apiKeyInput = document.getElementById('roboflow-api-key');
                                if (apiKeyInput) {
                                    if (stats.api_key_set) {
                                        apiKeyInput.placeholder = 'Saved (hidden)';
                                        apiKeyInput.value = '';
                                    } else {
                                        apiKeyInput.placeholder = 'Leave empty for public models';
                                    }
                                }
                            }
                        }
                        
                        // Sync UI with server state
                        document.getElementById('object-enabled').checked = data.enabled;
                        document.getElementById('object-auto-track-enabled').checked = data.auto_track;
                        document.getElementById('target-priority').value = data.priority;

                        const detectBtn = document.getElementById('overlay-objects-detect');
                        if (detectBtn) detectBtn.classList.toggle('active', !!data.enabled);
                        const trackBtn = document.getElementById('overlay-objects-track');
                        if (trackBtn) trackBtn.classList.toggle('active', !!data.auto_track);
                        syncOverlayConfidenceFromMain();
                    }
                })
                .catch(error => console.error('Error fetching object status:', error));
        }

        // Balloon UI helpers
        function showHideBalloonSettings() {
            const method = document.getElementById('detection-method').value;
            const modeEl = document.getElementById('detection-mode');
            const mode = modeEl ? modeEl.value : 'face';
            const balloonSettings = document.getElementById('balloon-settings');
            if (!balloonSettings) return;
            if (method === 'haar' && mode === 'balloon') {
                balloonSettings.style.display = 'block';
            } else {
                balloonSettings.style.display = 'none';
            }
        }

        function updateBalloonVValue() {
            const v = document.getElementById('balloon-v-threshold').value;
            document.getElementById('balloon-v-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonMinAreaValue() {
            const v = document.getElementById('balloon-min-area').value;
            document.getElementById('balloon-min-area-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonCircularityValue() {
            const v = parseFloat(document.getElementById('balloon-circularity').value).toFixed(2);
            document.getElementById('balloon-circularity-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonFillValue() {
            const v = parseFloat(document.getElementById('balloon-fill').value).toFixed(2);
            document.getElementById('balloon-fill-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonARMinValue() {
            const v = parseFloat(document.getElementById('balloon-ar-min').value).toFixed(2);
            document.getElementById('balloon-ar-min-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }
        function updateBalloonARMaxValue() {
            const v = parseFloat(document.getElementById('balloon-ar-max').value).toFixed(2);
            document.getElementById('balloon-ar-max-value').textContent = v;
            balloonLastEditTs = Date.now();
            balloonEditing = true;
        }

        function applyBalloonSettings() {
            const payload = {
                v_threshold: parseInt(document.getElementById('balloon-v-threshold').value),
                min_area: parseInt(document.getElementById('balloon-min-area').value),
                circularity_min: parseFloat(document.getElementById('balloon-circularity').value),
                fill_ratio_min: parseFloat(document.getElementById('balloon-fill').value),
                aspect_ratio_min: parseFloat(document.getElementById('balloon-ar-min').value),
                aspect_ratio_max: parseFloat(document.getElementById('balloon-ar-max').value)
            };
            fetch('/balloon/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('object-status-message', true, 'Balloon settings applied');
                    balloonEditing = false;
                    updateObjectStatus();
                } else {
                    showStatus('object-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('object-status-message', false, 'Failed to apply balloon settings');
                console.error('Error applying balloon settings:', error);
            });
        }

        // Motion detection controls
        function toggleMotionDetection() {
            const enabled = document.getElementById('motion-enabled').checked;
            fetch('/motion_detection/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('motion-status-message', true, 
                        enabled ? 'Motion detection enabled' : 'Motion detection disabled');
                    updateMotionStatus();
                } else {
                    showStatus('motion-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('motion-status-message', false, 'Failed to toggle motion detection');
                console.error('Error toggling motion detection:', error);
            });
        }

        function toggleAutoTrack() {
            const enabled = document.getElementById('auto-track-enabled').checked;
            fetch('/motion_detection/auto_track', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('motion-status-message', true, 
                        enabled ? 'Auto-tracking enabled' : 'Auto-tracking disabled');
                } else {
                    showStatus('motion-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('motion-status-message', false, 'Failed to toggle auto-track');
                console.error('Error toggling auto-track:', error);
            });
        }

        function updateSensitivityValue() {
            const value = document.getElementById('motion-sensitivity').value;
            document.getElementById('sensitivity-value').textContent = value;
        }

        function updateMinAreaValue() {
            const value = document.getElementById('motion-min-area').value;
            document.getElementById('min-area-value').textContent = value;
        }

        function applyMotionSettings() {
            const sensitivity = parseInt(document.getElementById('motion-sensitivity').value);
            const minArea = parseInt(document.getElementById('motion-min-area').value);
            
            fetch('/motion_detection/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sensitivity: sensitivity,
                    min_area: minArea
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('motion-status-message', true, 'Motion settings applied');
                    syncMotionSliders(); // Sync sliders after successful apply
                } else {
                    showStatus('motion-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('motion-status-message', false, 'Failed to apply motion settings');
                console.error('Error applying motion settings:', error);
            });
        }

        function updateMotionStatus() {
            fetch('/motion_detection/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('motion-status').textContent = 
                            data.enabled ? 'ON' : 'OFF';
                        document.getElementById('motion-detected').textContent = 
                            data.motion_detected ? 'Yes' : 'No';
                        
                        // Sync toggles with server state
                        document.getElementById('motion-enabled').checked = data.enabled;
                        document.getElementById('auto-track-enabled').checked = data.auto_track;
                        
                        // Don't sync sliders here - let user adjust them before applying
                        // Only sync sliders on page load or after applying settings
                    }
                })
                .catch(error => console.error('Error fetching motion status:', error));
        }
        
        function syncMotionSliders() {
            // Sync motion sliders with server state (called on page load only)
            fetch('/motion_detection/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('motion-sensitivity').value = data.sensitivity;
                        document.getElementById('motion-min-area').value = data.min_area;
                        updateSensitivityValue();
                        updateMinAreaValue();
                    }
                })
                .catch(error => console.error('Error fetching motion status:', error));
        }
        
        function syncLaserSliders() {
            // Sync laser sliders with server state (called on page load only)
            fetch('/laser/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('pulse-duration').value = data.pulse_duration * 1000;
                        document.getElementById('burst-count').value = data.burst_count;
                        document.getElementById('burst-delay').value = data.burst_delay * 1000;
                        document.getElementById('laser-cooldown').value = data.cooldown;
                        if (data.power !== undefined) {
                            document.getElementById('laser-power').value = data.power;
                        }
                        updatePulseDurationValue();
                        updateBurstCountValue();
                        updateBurstDelayValue();
                        updateLaserCooldownValue();
                        updateLaserPowerValue();
                    }
                })
                .catch(error => console.error('Error syncing laser sliders:', error));
        }

        // Update crosshair position display
        function updateCrosshairPosition() {
            fetch('/get_crosshair_position')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('crosshair-position').textContent = 
                            `${data.relative_x}, ${data.relative_y}`;
                    }
                })
                .catch(error => console.error('Error fetching crosshair position:', error));
        }

        // Update stats periodically
        function updateStats() {
            fetch('/exposure_stats')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('exp-time').textContent = 
                        `${(data.exposure_time/1000).toFixed(1)} ms`;
                    document.getElementById('gain').textContent = 
                        `${data.analog_gain.toFixed(2)}x`;
                });

            fetch('/get_fps')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('fps').textContent = `${data.fps} FPS`;
                });

            fetch('/get_camera_settings')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('digital-gain').textContent = 
                            `${data.settings.digital_gain.toFixed(2)}x`;
                    }
                });
            
            // Update recording status if on capture tab
            updateRecordingStatus();
            
            // Update laser status
            updateLaserStatus();
            
            // Update object detection status
            updateObjectStatus();
            
            // Update motion detection status
            updateMotionStatus();
            
            // Update pattern status
            updatePatternStatus();
            
            // Update crosshair position
            updateCrosshairPosition();
            updateCrosshairCalibration();
        }

        // Camera tracking controls
        function setTrackingMode() {
            const mode = document.getElementById('tracking-mode').value;
            
            fetch('/tracking/mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: mode })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    updateTrackingModeUI(mode);
                    showStatus('tracking-status-message', true, 
                        mode === 'crosshair' ? 'Crosshair tracking mode active' : 'Camera tracking mode active');
                    updateCameraTrackingStatus();
                } else {
                    showStatus('tracking-status-message', false, data.message);
                    // Revert to previous mode on error
                    document.getElementById('tracking-mode').value = 
                        mode === 'crosshair' ? 'camera' : 'crosshair';
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to set tracking mode');
                console.error('Error setting tracking mode:', error);
            });
        }

        function updateTrackingModeUI(mode) {
            const cameraControls = document.getElementById('camera-tracking-controls');
            const infoBox = document.getElementById('tracking-mode-info');
            
            if (mode === 'camera') {
                cameraControls.style.display = 'block';
                infoBox.innerHTML = '<strong>Camera Mode:</strong> Physically moves the camera with stepper motors to keep objects centered. Crosshair stays fixed.';
                infoBox.style.background = '#fff3cd';
                infoBox.style.color = '#856404';
            } else {
                cameraControls.style.display = 'none';
                infoBox.innerHTML = '<strong>Crosshair Mode:</strong> Tracks objects by moving the crosshair on screen. Camera stays fixed.';
                infoBox.style.background = '#e3f2fd';
                infoBox.style.color = '#1565c0';
            }
        }

        function toggleCameraTracking() {
            const enabled = document.getElementById('camera-tracking-enabled').checked;
            
            fetch('/tracking/camera/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 
                        enabled ? 'Camera tracking enabled' : 'Camera tracking disabled');
                    updateCameraTrackingStatus();
                } else {
                    showStatus('tracking-status-message', false, data.message);
                    document.getElementById('camera-tracking-enabled').checked = !enabled;
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to toggle camera tracking');
                console.error('Error toggling camera tracking:', error);
                document.getElementById('camera-tracking-enabled').checked = !enabled;
            });
        }

        function toggleRecenterOnLoss() {
            const enabled = document.getElementById('camera-recenter-on-loss').checked;
            fetch('/tracking/camera/recenter_on_loss', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, enabled ? 'Re-center on loss enabled' : 'Re-center on loss disabled');
                } else {
                    showStatus('tracking-status-message', false, data.message || 'Failed to set re-center on loss');
                    document.getElementById('camera-recenter-on-loss').checked = !enabled;
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to set re-center on loss');
                console.error('Error toggling re-center on loss:', error);
                document.getElementById('camera-recenter-on-loss').checked = !enabled;
            });
        }

        function homeCameraPosition() {
            fetch('/tracking/camera/home', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 'Homing camera to center position...');
                    setTimeout(updateCameraTrackingStatus, 1000);
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to home camera');
                console.error('Error homing camera:', error);
            });
        }

        function updateCameraDeadZoneValue() {
            const value = document.getElementById('camera-dead-zone').value;
            document.getElementById('camera-dead-zone-value').textContent = value + 'px';
        }

        function updateCameraStepDelayValue() {
            const sliderValue = parseFloat(document.getElementById('camera-step-delay').value);
            // Invert slider: higher slider value = lower delay (faster)
            const actualDelay = 0.0055 - sliderValue;
            document.getElementById('camera-step-delay-value').textContent = (actualDelay * 1000).toFixed(1) + 'ms';
        }

        // Track whether calibration sliders have been initialized from server
        let calibrationSlidersInitialized = false;

        function updateCameraXStepsValue() {
            const value = parseFloat(document.getElementById('camera-x-steps-per-pixel').value).toFixed(2);
            document.getElementById('camera-x-steps-value').textContent = value;
        }

        function updateCameraYStepsValue() {
            const value = parseFloat(document.getElementById('camera-y-steps-per-pixel').value).toFixed(2);
            document.getElementById('camera-y-steps-value').textContent = value;
        }

        function applyCameraTrackingSettings() {
            const deadZone = parseInt(document.getElementById('camera-dead-zone').value);
            const sliderValue = parseFloat(document.getElementById('camera-step-delay').value);
            // Invert slider: higher slider value = lower delay (faster)
            const stepDelay = 0.0055 - sliderValue;
            
            fetch('/tracking/camera/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    dead_zone_pixels: deadZone,
                    step_delay: stepDelay
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 'Camera tracking settings applied');
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to apply settings');
                console.error('Error applying camera settings:', error);
            });
        }

        function updatePIDLabel(kind) {
            const el = document.getElementById(`pid-${kind}`);
            const val = parseFloat(el.value);
            const label = document.getElementById(`pid-${kind}-value`);
            if (label) label.textContent = val.toFixed(2);
            pidEditing = true;
            pidLastEditTs = Date.now();
        }

        function applyPID() {
            const kp = parseFloat(document.getElementById('pid-kp').value);
            const ki = parseFloat(document.getElementById('pid-ki').value);
            const kd = parseFloat(document.getElementById('pid-kd').value);
            fetch('/tracking/camera/pid', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ kp: kp, ki: ki, kd: kd })
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 'PID settings applied');
                    pidEditing = false;
                } else {
                    showStatus('tracking-status-message', false, data.message || 'Failed to apply PID');
                }
            })
            .catch(err => {
                console.error('Error applying PID:', err);
                showStatus('tracking-status-message', false, 'Failed to apply PID');
            });
        }

        function applyCameraCalibration() {
            const xSteps = parseFloat(document.getElementById('camera-x-steps-per-pixel').value);
            const ySteps = parseFloat(document.getElementById('camera-y-steps-per-pixel').value);
            
            fetch('/tracking/camera/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    x_steps_per_pixel: xSteps,
                    y_steps_per_pixel: ySteps
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, 'Calibration saved');
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to save calibration');
                console.error('Error saving calibration:', error);
            });
        }

        let overlayConfidenceTimeout = null;

        function toggleOverlayPanel(panelId, button) {
            const panel = document.getElementById(panelId);
            if (!panel) return;
            const isActive = panel.classList.contains('active');
            panel.classList.toggle('active', !isActive);
            if (button) {
                button.classList.toggle('active', !isActive);
            } else {
                const key = panel.dataset.overlayKey;
                if (key) {
                    const toggleBtn = document.querySelector(`.toolbar-button[data-overlay-target="${key}"]`);
                    if (toggleBtn) {
                        toggleBtn.classList.toggle('active', panel.classList.contains('active'));
                    }
                }
            }
        }

        function toggleMotorsFromToolbar() {
            const toggle = document.getElementById('camera-tracking-enabled');
            if (!toggle) return;
            toggle.checked = !toggle.checked;
            toggleCameraTracking();
        }

        function syncMotorsToolbar(enabled) {
            const stateEl = document.getElementById('motors-state');
            if (stateEl) {
                stateEl.textContent = enabled ? 'ON' : 'OFF';
            }
            const btn = document.getElementById('motors-toggle');
            if (btn) {
                btn.classList.toggle('active', !!enabled);
            }
        }

        function toggleOverlayRecenter(button) {
            const checkbox = document.getElementById('camera-recenter-on-loss');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            button.classList.toggle('active', checkbox.checked);
            toggleRecenterOnLoss();
            setTimeout(() => {
                updateCameraTrackingStatus();
            }, 500);
        }

        function syncRecenterOverlayButton() {
            const checkbox = document.getElementById('camera-recenter-on-loss');
            const button = document.getElementById('recenter-toggle-btn');
            if (checkbox && button) {
                button.classList.toggle('active', checkbox.checked);
            }
        }

        function toggleLaserFromOverlay() {
            const checkbox = document.getElementById('laser-enabled');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            toggleLaser();
        }

        function toggleAutoFireFromOverlay() {
            const checkbox = document.getElementById('auto-fire-enabled');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            toggleAutoFire();
        }

        function toggleObjectDetectionFromOverlay() {
            const checkbox = document.getElementById('object-enabled');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            toggleObjectDetection();
        }

        function toggleObjectAutoTrackFromOverlay() {
            const checkbox = document.getElementById('object-auto-track-enabled');
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            toggleObjectAutoTrack();
        }

        function syncLaserOverlay(status) {
            const systemEl = document.getElementById('overlay-laser-status');
            const readyEl = document.getElementById('overlay-laser-ready');
            const powerEl = document.getElementById('overlay-laser-power');
            const cooldownEl = document.getElementById('overlay-laser-cooldown');
            const enableBtn = document.getElementById('overlay-laser-enable');
            const autoBtn = document.getElementById('overlay-auto-fire');

            if (systemEl) systemEl.textContent = status.enabled ? 'ON' : 'OFF';
            const fireReady = status.ready_to_fire && status.enabled;
            if (readyEl) readyEl.textContent = fireReady ? 'Yes' : 'No';
            if (powerEl && status.power !== undefined) powerEl.textContent = `${status.power}%`;
            if (cooldownEl) {
                if (status.cooldown_remaining > 0) {
                    cooldownEl.textContent = `${status.cooldown_remaining.toFixed(1)}s`;
                } else {
                    cooldownEl.textContent = 'Ready';
                }
            }
            if (enableBtn) enableBtn.classList.toggle('active', !!status.enabled);
            if (autoBtn) autoBtn.classList.toggle('active', !!status.auto_fire);
        }

        function syncOverlayConfidenceFromMain() {
            const overlaySlider = document.getElementById('overlay-object-confidence');
            const overlayValue = document.getElementById('overlay-object-confidence-value');
            const hint = document.getElementById('overlay-object-hint');
            const methodEl = document.getElementById('detection-method');
            if (!overlaySlider || !overlayValue || !methodEl || !hint) return;

            const method = methodEl.value;
            if (method === 'haar') {
                overlaySlider.disabled = true;
                hint.style.display = 'block';
                overlayValue.textContent = '--';
                return;
            }

            hint.style.display = 'none';
            overlaySlider.disabled = false;

            let value = parseFloat(overlaySlider.value);
            if (method === 'tflite') {
                const slider = document.getElementById('tflite-confidence');
                if (slider) {
                    value = parseFloat(slider.value);
                }
            } else if (method === 'roboflow') {
                const slider = document.getElementById('roboflow-confidence');
                if (slider) {
                    value = parseFloat(slider.value);
                }
            }

            if (!Number.isNaN(value)) {
                overlaySlider.value = value;
                overlayValue.textContent = value.toFixed(2);
            }
        }

        function handleOverlayConfidenceInput(value) {
            const overlayValue = document.getElementById('overlay-object-confidence-value');
            const methodEl = document.getElementById('detection-method');
            if (overlayValue) {
                const num = parseFloat(value);
                if (!Number.isNaN(num)) {
                    overlayValue.textContent = num.toFixed(2);
                }
            }
            if (!methodEl) return;

            const method = methodEl.value;
            if (method === 'haar') {
                return;
            }

            if (method === 'tflite') {
                const slider = document.getElementById('tflite-confidence');
                if (slider) {
                    slider.value = value;
                    updateTFLiteConfidence();
                }
            } else if (method === 'roboflow') {
                const slider = document.getElementById('roboflow-confidence');
                if (slider) {
                    slider.value = value;
                    updateRoboflowConfidence();
                }
            }

            if (overlayConfidenceTimeout) {
                clearTimeout(overlayConfidenceTimeout);
            }
            overlayConfidenceTimeout = setTimeout(() => {
                if (method === 'tflite') {
                    applyTFLiteSettings();
                } else if (method === 'roboflow') {
                    applyRoboflowSettings();
                }
            }, 500);
        }

        function updateManualStepSize() {
            const value = document.getElementById('manual-step-size').value;
            document.getElementById('manual-step-size-value').textContent = `${value} px`;
        }

        function manualMove(axis, steps) {
            // Use the step size from slider instead of hardcoded value
            const stepSize = parseInt(document.getElementById('manual-step-size').value);
            const actualSteps = steps > 0 ? stepSize : -stepSize;
            
            fetch('/tracking/camera/manual_move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    axis: axis,
                    steps: actualSteps
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, data.message);
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to move camera');
                console.error('Error moving camera:', error);
            });
        }

        function setHomePosition() {
            if (!confirm('Set current position as home (0, 0)?')) return;
            
            fetch('/tracking/camera/set_home', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, data.message);
                    updateCameraTrackingStatus();
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to set home position');
                console.error('Error setting home position:', error);
            });
        }

        function runAutoCalibration() {
            if (!confirm('Run automatic calibration? This will move the camera through its full range of motion and may take several minutes. Ensure the area is clear.')) return;
            
            fetch('/tracking/camera/auto_calibrate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('tracking-status-message', true, data.message);
                    // Poll status more frequently during calibration
                    setTimeout(() => {
                        updateCameraTrackingStatus();
                    }, 5000);
                } else {
                    showStatus('tracking-status-message', false, data.message);
                }
            })
            .catch(error => {
                showStatus('tracking-status-message', false, 'Failed to start auto-calibration');
                console.error('Error starting auto-calibration:', error);
            });
        }

        function updateCalibrationUI(isCalibrated, timestamp) {
            // Update calibration status display
            if (isCalibrated) {
                document.getElementById('camera-calibration-status').textContent = 'Calibrated âœ“';
                document.getElementById('camera-calibration-status').style.color = '#28a745';
                document.getElementById('calibration-required-warning').style.display = 'none';
                
                // Enable controls
                document.getElementById('camera-tracking-enabled').disabled = false;
                document.getElementById('home-camera-btn').disabled = false;
                
                // Enable manual control buttons
                document.querySelectorAll('[onclick^="manualMove"]').forEach(btn => {
                    btn.disabled = false;
                });
                document.querySelectorAll('[onclick="setHomePosition()"]').forEach(btn => {
                    btn.disabled = false;
                });
                document.querySelectorAll('[onclick="homeCameraPosition()"]').forEach(btn => {
                    btn.disabled = false;
                });
            } else {
                document.getElementById('camera-calibration-status').textContent = 'Not Calibrated';
                document.getElementById('camera-calibration-status').style.color = '#dc3545';
                document.getElementById('calibration-required-warning').style.display = 'block';
                
                // Disable controls
                document.getElementById('camera-tracking-enabled').disabled = true;
                document.getElementById('camera-tracking-enabled').checked = false;
                document.getElementById('home-camera-btn').disabled = true;
                
                // Disable manual control buttons
                document.querySelectorAll('[onclick^="manualMove"]').forEach(btn => {
                    btn.disabled = true;
                });
                document.querySelectorAll('[onclick="setHomePosition()"]').forEach(btn => {
                    btn.disabled = true;
                });
                document.querySelectorAll('[onclick="homeCameraPosition()"]').forEach(btn => {
                    btn.disabled = true;
                });
            }
        }

        function updateCameraTrackingStatus() {
            fetch('/tracking/camera/status')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Update tracking mode dropdown if needed
                        if (data.mode) {
                            document.getElementById('tracking-mode').value = data.mode;
                            updateTrackingModeUI(data.mode);
                        }
                        
                        if (data.available) {
                            document.getElementById('camera-system-status').textContent = 'Available';
                            document.getElementById('camera-enabled-status').textContent =
                                data.enabled ? 'Yes' : 'No';
                            syncMotorsToolbar(!!data.enabled);
                            // Sync re-center on loss toggle
                            const r = !!data.recenter_on_loss;
                            const rEl = document.getElementById('camera-recenter-on-loss');
                            if (rEl) rEl.checked = r;
                            syncRecenterOverlayButton();
                            
                            const controller = data.controller_status;
                            if (controller) {
                                document.getElementById('camera-position').textContent = 
                                    `${controller.position.x}, ${controller.position.y}`;
                                document.getElementById('camera-moving').textContent = 
                                    controller.moving ? 'Yes' : 'No';
                                
                                // Update crosshair position
                                updateCrosshairPosition();
                                
                                // Initialize calibration sliders ONLY on first load
                                // After that, preserve user's values until they save or refresh page
                                if (controller.calibration && !calibrationSlidersInitialized) {
                                    document.getElementById('camera-x-steps-per-pixel').value = 
                                        controller.calibration.x_steps_per_pixel;
                                    document.getElementById('camera-x-steps-value').textContent = 
                                        controller.calibration.x_steps_per_pixel.toFixed(2);
                                    
                                    document.getElementById('camera-y-steps-per-pixel').value = 
                                        controller.calibration.y_steps_per_pixel;
                                    document.getElementById('camera-y-steps-value').textContent = 
                                        controller.calibration.y_steps_per_pixel.toFixed(2);
                                    
                                    document.getElementById('camera-dead-zone').value = 
                                        controller.calibration.dead_zone_pixels;
                                    updateCameraDeadZoneValue();

                                    if (typeof controller.calibration.step_delay === 'number') {
                                        const sliderEl = document.getElementById('camera-step-delay');
                                        if (sliderEl) {
                                            let sliderVal = 0.0055 - controller.calibration.step_delay;
                                            sliderVal = Math.max(0.0005, Math.min(0.005, sliderVal));
                                            sliderEl.value = sliderVal;
                                            updateCameraStepDelayValue();
                                        }
                                    }
                                    
                                    // Mark as initialized so we don't overwrite user changes
                                    calibrationSlidersInitialized = true;
                                }
                                
                                // Update calibration status UI
                                if (controller.calibration) {
                                    updateCalibrationUI(
                                        controller.calibration.is_calibrated,
                                        controller.calibration.calibration_timestamp
                                    );
                                }
                                
                                // Sync PID sliders with controller values
                                fetch('/tracking/camera/pid')
                                    .then(r => r.json())
                                    .then(pd => {
                                        if (pd.status === 'success' && pd.pid) {
                                            const now = Date.now();
                                            const allowPIDSync = !pidEditing || (now - pidLastEditTs > EDIT_IDLE_MS);
                                            if (allowPIDSync) {
                                                const p = pd.pid;
                                                const kpEl = document.getElementById('pid-kp');
                                                const kiEl = document.getElementById('pid-ki');
                                                const kdEl = document.getElementById('pid-kd');
                                                const kpVal = document.getElementById('pid-kp-value');
                                                const kiVal = document.getElementById('pid-ki-value');
                                                const kdVal = document.getElementById('pid-kd-value');
                                                if (kpEl && kpVal) { kpEl.value = p.kp; kpVal.textContent = parseFloat(p.kp).toFixed(2); }
                                                if (kiEl && kiVal) { kiEl.value = p.ki; kiVal.textContent = parseFloat(p.ki).toFixed(2); }
                                                if (kdEl && kdVal) { kdEl.value = p.kd; kdVal.textContent = parseFloat(p.kd).toFixed(2); }
                                            }
                                        }
                                    })
                                    .catch(() => {});
                            }
                            
                            document.getElementById('camera-tracking-enabled').checked = data.enabled;
                        } else {
                            document.getElementById('camera-system-status').textContent = 'Not Available';
                            document.getElementById('camera-enabled-status').textContent = 'N/A';
                            syncMotorsToolbar(false);
                            syncRecenterOverlayButton();
                        }
                    }
                })
                .catch(error => console.error('Error fetching camera tracking status:', error));
        }

        // ============================================================
        // WebSocket Communication Setup
        // ============================================================
        
        // Connect to Socket.IO server
        const socket = io();
        
        // Handle connection events
        socket.on('connect', () => {
            console.log('âœ… WebSocket connected');
        });
        
        socket.on('disconnect', () => {
            console.warn('âŒ WebSocket disconnected');
        });
        
        socket.on('connect_error', (error) => {
            console.error('WebSocket connection error:', error);
        });
        
        // Helper function to safely update DOM elements
        function safeUpdateElement(id, value) {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
            }
        }
        
        // Listen for consolidated status updates from server
        socket.on('status_update', (status) => {
            // Update FPS
            if (status.fps !== undefined) {
                safeUpdateElement('fps', `${status.fps} FPS`);
            }
            
            // Update exposure stats
            if (status.exposure) {
                safeUpdateElement('exp-time', `${(status.exposure.exposure_time/1000).toFixed(1)} ms`);
                safeUpdateElement('gain', `${status.exposure.analog_gain.toFixed(2)}x`);
                if (status.exposure.digital_gain !== undefined) {
                    safeUpdateElement('digital-gain', `${status.exposure.digital_gain.toFixed(2)}x`);
                }
            }
            
            // Update crosshair position
            if (status.crosshair) {
                const relX = status.crosshair.relative_x;
                const relY = status.crosshair.relative_y;
                safeUpdateElement('position', `(${relX >= 0 ? '+' : ''}${relX}, ${relY >= 0 ? '+' : ''}${relY})`);
                safeUpdateElement('crosshair-position', `${status.crosshair.absolute_x}, ${status.crosshair.absolute_y}`);
            }
            
            // Update crosshair calibration
            if (status.crosshair_calibration) {
                safeUpdateElement('crosshair-offset', `${status.crosshair_calibration.x}, ${status.crosshair_calibration.y}`);
            }
            
            // Update laser status
            if (status.laser) {
                syncLaserOverlay(status.laser);
                safeUpdateElement('laser-system-status', status.laser.enabled ? 'ON' : 'OFF');
                safeUpdateElement('laser-ready', status.laser.ready_to_fire ? 'Yes' : 'No');
                safeUpdateElement('laser-fire-count', status.laser.fire_count);
                
                // Update cooldown remaining
                if (status.laser.cooldown_remaining > 0) {
                    safeUpdateElement('laser-cooldown-remaining', status.laser.cooldown_remaining.toFixed(1) + 's');
                } else {
                    safeUpdateElement('laser-cooldown-remaining', 'Ready');
                }
                
                // Update power level and hardware status
                if (status.laser.power !== undefined) {
                    safeUpdateElement('laser-power-level', status.laser.power + '%');
                }
                safeUpdateElement('laser-hardware-status', status.laser.hardware_available ? 'Connected' : 'Simulation');
                
                // Update checkboxes
                const laserEnabledEl = document.getElementById('laser-enabled');
                if (laserEnabledEl) laserEnabledEl.checked = status.laser.enabled;
                
                const autoFireEl = document.getElementById('auto-fire-enabled');
                if (autoFireEl) autoFireEl.checked = status.laser.auto_fire;
                
                // NOTE: Laser sliders are NOT synced from WebSocket (like motion detection)
                // They are only updated on page load and when user clicks Apply
                // This prevents sliders from reverting while user is adjusting them
                
                // Update fire button state
                const fireReady = status.laser.ready_to_fire && status.laser.enabled;
                document.querySelectorAll('[data-fire-control]').forEach(btn => {
                    btn.disabled = !fireReady;
                });
            }
            
            // Update object detection status
            if (status.object_detection) {
                const objEnabled = status.object_detection.enabled;
                const objAutoTrack = status.object_detection.auto_track;
                const objCount = status.object_detection.count;
                const objMode = status.object_detection.mode;
                const objMethod = status.object_detection.method;

                safeUpdateElement('object-detection-status', objEnabled ? 'Enabled' : 'Disabled');
                safeUpdateElement('object-auto-track-status', objAutoTrack ? 'Yes' : 'No');
                safeUpdateElement('object-count', objCount);
                safeUpdateElement('object-detection-mode', objMode ? objMode.toUpperCase() : 'N/A');
                safeUpdateElement('detection-method-display', objMethod ? objMethod.toUpperCase() : 'N/A');

                const detectBtn = document.getElementById('overlay-objects-detect');
                if (detectBtn) detectBtn.classList.toggle('active', !!objEnabled);
                const trackBtn = document.getElementById('overlay-objects-track');
                if (trackBtn) trackBtn.classList.toggle('active', !!objAutoTrack);
                syncOverlayConfidenceFromMain();
            }
            
            // Update motion detection status
            if (status.motion_detection) {
                const motionEnabled = status.motion_detection.enabled;
                const motionAutoTrack = status.motion_detection.auto_track;
                const hasMotion = status.motion_detection.has_motion;
                
                safeUpdateElement('motion-detection-status', motionEnabled ? 'Enabled' : 'Disabled');
                safeUpdateElement('motion-auto-track-status', motionAutoTrack ? 'Yes' : 'No');
                safeUpdateElement('motion-detected', hasMotion ? 'Yes' : 'No');
            }
            
            // Update recording status
            if (status.recording) {
                safeUpdateElement('recording-status', status.recording.is_recording ? 'Recording' : 'Not Recording');
                if (status.recording.is_recording) {
                    const duration = Math.floor(status.recording.duration);
                    const mins = Math.floor(duration / 60);
                    const secs = duration % 60;
                    safeUpdateElement('recording-duration', `${mins}:${secs.toString().padStart(2, '0')}`);
                }
                if (status.recording.filename) {
                    safeUpdateElement('recording-filename', status.recording.filename);
                }
            }
            
            // Update pattern status
            if (status.pattern) {
                safeUpdateElement('pattern-status', status.pattern.running ? 'Running' : 'Stopped');
            }
            
            // Update tracking mode status
            if (status.tracking) {
                const trackMode = document.getElementById('tracking-mode');
                if (trackMode && trackMode.value !== status.tracking.mode) {
                    trackMode.value = status.tracking.mode;
                    updateTrackingModeUI(status.tracking.mode);
                }
            }
            
            // Update camera controller status (detailed)
            if (status.controller) {
                const ctrl = status.controller;
                
                safeUpdateElement('camera-system-status', 'Available');
                safeUpdateElement('camera-enabled-status', status.tracking.camera_enabled ? 'Yes' : 'No');
                
                // Update re-center on loss toggle
                const recenterEl = document.getElementById('camera-recenter-on-loss');
                if (recenterEl) {
                    recenterEl.checked = !!status.tracking.recenter_on_loss;
                }
                
                if (ctrl.position) {
                    safeUpdateElement('camera-position', `${ctrl.position.x}, ${ctrl.position.y}`);
                }
                
                safeUpdateElement('camera-moving', ctrl.moving ? 'Yes' : 'No');
                
                // Initialize calibration sliders ONLY on first load
                if (ctrl.calibration && !calibrationSlidersInitialized) {
                    const xStepsEl = document.getElementById('camera-x-steps-per-pixel');
                    const xStepsValEl = document.getElementById('camera-x-steps-value');
                    const yStepsEl = document.getElementById('camera-y-steps-per-pixel');
                    const yStepsValEl = document.getElementById('camera-y-steps-value');
                    const deadZoneEl = document.getElementById('camera-dead-zone');
                    const stepDelayEl = document.getElementById('camera-step-delay');
                    
                    if (xStepsEl && xStepsValEl) {
                        xStepsEl.value = ctrl.calibration.x_steps_per_pixel;
                        xStepsValEl.textContent = ctrl.calibration.x_steps_per_pixel.toFixed(2);
                    }
                    
                    if (yStepsEl && yStepsValEl) {
                        yStepsEl.value = ctrl.calibration.y_steps_per_pixel;
                        yStepsValEl.textContent = ctrl.calibration.y_steps_per_pixel.toFixed(2);
                    }
                    
                    if (deadZoneEl) {
                        deadZoneEl.value = ctrl.calibration.dead_zone_pixels;
                        updateCameraDeadZoneValue();
                    }
                    
                    if (stepDelayEl && typeof ctrl.calibration.step_delay === 'number') {
                        let sliderVal = 0.0055 - ctrl.calibration.step_delay;
                        sliderVal = Math.max(0.0005, Math.min(0.005, sliderVal));
                        stepDelayEl.value = sliderVal;
                        updateCameraStepDelayValue();
                    }
                    
                    calibrationSlidersInitialized = true;
                }
                
                // Update calibration status UI
                if (ctrl.calibration) {
                    updateCalibrationUI(
                        ctrl.calibration.is_calibrated,
                        ctrl.calibration.calibration_timestamp
                    );
                }
                
                // Sync PID sliders with controller values (with edit protection)
                if (ctrl.pid) {
                    const now = Date.now();
                    const allowPIDSync = !pidEditing || (now - pidLastEditTs > EDIT_IDLE_MS);
                    if (allowPIDSync) {
                        const kpEl = document.getElementById('pid-kp');
                        const kiEl = document.getElementById('pid-ki');
                        const kdEl = document.getElementById('pid-kd');
                        const kpVal = document.getElementById('pid-kp-value');
                        const kiVal = document.getElementById('pid-ki-value');
                        const kdVal = document.getElementById('pid-kd-value');
                        if (kpEl && kpVal) { kpEl.value = ctrl.pid.kp; kpVal.textContent = parseFloat(ctrl.pid.kp).toFixed(2); }
                        if (kiEl && kiVal) { kiEl.value = ctrl.pid.ki; kiVal.textContent = parseFloat(ctrl.pid.ki).toFixed(2); }
                        if (kdEl && kdVal) { kdEl.value = ctrl.pid.kd; kdVal.textContent = parseFloat(ctrl.pid.kd).toFixed(2); }
                    }
                }
                
                const camTrackEl = document.getElementById('camera-tracking-enabled');
                if (camTrackEl) {
                    camTrackEl.checked = status.tracking.camera_enabled;
                }
                syncMotorsToolbar(!!status.tracking.camera_enabled);
                syncRecenterOverlayButton();
            } else if (status.tracking && !status.tracking.camera_enabled) {
                safeUpdateElement('camera-system-status', 'Not Available');
                safeUpdateElement('camera-enabled-status', 'N/A');
                syncMotorsToolbar(false);
                syncRecenterOverlayButton();
            }
        });
        
        // ============================================================
        // Page Initialization
        // ============================================================
        
        async function initializeDetectionMethodFromConfig() {
            try {
                const resp = await fetch('/detection_method/config');
                const data = await resp.json();
                if (data && data.status === 'success' && data.method) {
                    // Ask backend to switch to configured method to ensure detectors are initialized
                    await fetch('/detection_method/switch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ method: data.method })
                    }).then(r => r.json()).catch(() => ({}));
                }
            } catch (e) {
                console.warn('Failed to initialize detection method from config:', e);
            }
        }

        (async () => {
            // Load presets on page load
            loadPresetList();

            // Sync sliders on page load (not from WebSocket)
            syncMotionSliders();
            syncLaserSliders();

            // Initialize camera step delay display
            updateCameraStepDelayValue();
            updateManualStepSize();
            syncOverlayConfidenceFromMain();
            syncRecenterOverlayButton();

            // Ensure backend detection method matches config before status pulls
            await initializeDetectionMethodFromConfig();

            updateLaserStatus();
            updateObjectStatus();
            updateCameraTrackingStatus();
        })();

        console.log('ðŸš€ Laser Turret Control Panel initialized with WebSocket support');
    </script>
</body>
</html>
